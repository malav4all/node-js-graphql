// Code generated by Prisma (prisma@1.20.7). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  amenities: (where?: AmenitiesWhereInput) => Promise<boolean>;
  booking: (where?: BookingWhereInput) => Promise<boolean>;
  city: (where?: CityWhereInput) => Promise<boolean>;
  creditCardInformation: (
    where?: CreditCardInformationWhereInput
  ) => Promise<boolean>;
  experience: (where?: ExperienceWhereInput) => Promise<boolean>;
  experienceCategory: (
    where?: ExperienceCategoryWhereInput
  ) => Promise<boolean>;
  guestRequirements: (where?: GuestRequirementsWhereInput) => Promise<boolean>;
  houseRules: (where?: HouseRulesWhereInput) => Promise<boolean>;
  location: (where?: LocationWhereInput) => Promise<boolean>;
  message: (where?: MessageWhereInput) => Promise<boolean>;
  neighbourhood: (where?: NeighbourhoodWhereInput) => Promise<boolean>;
  notification: (where?: NotificationWhereInput) => Promise<boolean>;
  payment: (where?: PaymentWhereInput) => Promise<boolean>;
  paymentAccount: (where?: PaymentAccountWhereInput) => Promise<boolean>;
  paypalInformation: (where?: PaypalInformationWhereInput) => Promise<boolean>;
  picture: (where?: PictureWhereInput) => Promise<boolean>;
  place: (where?: PlaceWhereInput) => Promise<boolean>;
  policies: (where?: PoliciesWhereInput) => Promise<boolean>;
  pricing: (where?: PricingWhereInput) => Promise<boolean>;
  restaurant: (where?: RestaurantWhereInput) => Promise<boolean>;
  review: (where?: ReviewWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  views: (where?: ViewsWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  amenities: (where: AmenitiesWhereUniqueInput) => AmenitiesPromise;
  amenitieses: (
    args?: {
      where?: AmenitiesWhereInput;
      orderBy?: AmenitiesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Amenities>;
  amenitiesesConnection: (
    args?: {
      where?: AmenitiesWhereInput;
      orderBy?: AmenitiesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AmenitiesConnectionPromise;
  booking: (where: BookingWhereUniqueInput) => BookingPromise;
  bookings: (
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Booking>;
  bookingsConnection: (
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BookingConnectionPromise;
  city: (where: CityWhereUniqueInput) => CityPromise;
  cities: (
    args?: {
      where?: CityWhereInput;
      orderBy?: CityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<City>;
  citiesConnection: (
    args?: {
      where?: CityWhereInput;
      orderBy?: CityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CityConnectionPromise;
  creditCardInformation: (
    where: CreditCardInformationWhereUniqueInput
  ) => CreditCardInformationPromise;
  creditCardInformations: (
    args?: {
      where?: CreditCardInformationWhereInput;
      orderBy?: CreditCardInformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CreditCardInformation>;
  creditCardInformationsConnection: (
    args?: {
      where?: CreditCardInformationWhereInput;
      orderBy?: CreditCardInformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CreditCardInformationConnectionPromise;
  experience: (where: ExperienceWhereUniqueInput) => ExperiencePromise;
  experiences: (
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Experience>;
  experiencesConnection: (
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExperienceConnectionPromise;
  experienceCategory: (
    where: ExperienceCategoryWhereUniqueInput
  ) => ExperienceCategoryPromise;
  experienceCategories: (
    args?: {
      where?: ExperienceCategoryWhereInput;
      orderBy?: ExperienceCategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ExperienceCategory>;
  experienceCategoriesConnection: (
    args?: {
      where?: ExperienceCategoryWhereInput;
      orderBy?: ExperienceCategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExperienceCategoryConnectionPromise;
  guestRequirements: (
    where: GuestRequirementsWhereUniqueInput
  ) => GuestRequirementsPromise;
  guestRequirementses: (
    args?: {
      where?: GuestRequirementsWhereInput;
      orderBy?: GuestRequirementsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GuestRequirements>;
  guestRequirementsesConnection: (
    args?: {
      where?: GuestRequirementsWhereInput;
      orderBy?: GuestRequirementsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GuestRequirementsConnectionPromise;
  houseRules: (where: HouseRulesWhereUniqueInput) => HouseRulesPromise;
  houseRuleses: (
    args?: {
      where?: HouseRulesWhereInput;
      orderBy?: HouseRulesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<HouseRules>;
  houseRulesesConnection: (
    args?: {
      where?: HouseRulesWhereInput;
      orderBy?: HouseRulesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HouseRulesConnectionPromise;
  location: (where: LocationWhereUniqueInput) => LocationPromise;
  locations: (
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Location>;
  locationsConnection: (
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LocationConnectionPromise;
  message: (where: MessageWhereUniqueInput) => MessagePromise;
  messages: (
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Message>;
  messagesConnection: (
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MessageConnectionPromise;
  neighbourhood: (where: NeighbourhoodWhereUniqueInput) => NeighbourhoodPromise;
  neighbourhoods: (
    args?: {
      where?: NeighbourhoodWhereInput;
      orderBy?: NeighbourhoodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Neighbourhood>;
  neighbourhoodsConnection: (
    args?: {
      where?: NeighbourhoodWhereInput;
      orderBy?: NeighbourhoodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => NeighbourhoodConnectionPromise;
  notification: (where: NotificationWhereUniqueInput) => NotificationPromise;
  notifications: (
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Notification>;
  notificationsConnection: (
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => NotificationConnectionPromise;
  payment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  payments: (
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Payment>;
  paymentsConnection: (
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PaymentConnectionPromise;
  paymentAccount: (
    where: PaymentAccountWhereUniqueInput
  ) => PaymentAccountPromise;
  paymentAccounts: (
    args?: {
      where?: PaymentAccountWhereInput;
      orderBy?: PaymentAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PaymentAccount>;
  paymentAccountsConnection: (
    args?: {
      where?: PaymentAccountWhereInput;
      orderBy?: PaymentAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PaymentAccountConnectionPromise;
  paypalInformation: (
    where: PaypalInformationWhereUniqueInput
  ) => PaypalInformationPromise;
  paypalInformations: (
    args?: {
      where?: PaypalInformationWhereInput;
      orderBy?: PaypalInformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PaypalInformation>;
  paypalInformationsConnection: (
    args?: {
      where?: PaypalInformationWhereInput;
      orderBy?: PaypalInformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PaypalInformationConnectionPromise;
  picture: (where: PictureWhereUniqueInput) => PicturePromise;
  pictures: (
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Picture>;
  picturesConnection: (
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PictureConnectionPromise;
  place: (where: PlaceWhereUniqueInput) => PlacePromise;
  places: (
    args?: {
      where?: PlaceWhereInput;
      orderBy?: PlaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Place>;
  placesConnection: (
    args?: {
      where?: PlaceWhereInput;
      orderBy?: PlaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PlaceConnectionPromise;
  policies: (where: PoliciesWhereUniqueInput) => PoliciesPromise;
  policieses: (
    args?: {
      where?: PoliciesWhereInput;
      orderBy?: PoliciesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Policies>;
  policiesesConnection: (
    args?: {
      where?: PoliciesWhereInput;
      orderBy?: PoliciesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PoliciesConnectionPromise;
  pricing: (where: PricingWhereUniqueInput) => PricingPromise;
  pricings: (
    args?: {
      where?: PricingWhereInput;
      orderBy?: PricingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Pricing>;
  pricingsConnection: (
    args?: {
      where?: PricingWhereInput;
      orderBy?: PricingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PricingConnectionPromise;
  restaurant: (where: RestaurantWhereUniqueInput) => RestaurantPromise;
  restaurants: (
    args?: {
      where?: RestaurantWhereInput;
      orderBy?: RestaurantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Restaurant>;
  restaurantsConnection: (
    args?: {
      where?: RestaurantWhereInput;
      orderBy?: RestaurantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RestaurantConnectionPromise;
  review: (where: ReviewWhereUniqueInput) => ReviewPromise;
  reviews: (
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Review>;
  reviewsConnection: (
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ReviewConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  views: (where: ViewsWhereUniqueInput) => ViewsPromise;
  viewses: (
    args?: {
      where?: ViewsWhereInput;
      orderBy?: ViewsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Views>;
  viewsesConnection: (
    args?: {
      where?: ViewsWhereInput;
      orderBy?: ViewsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ViewsConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAmenities: (data: AmenitiesCreateInput) => AmenitiesPromise;
  updateAmenities: (
    args: { data: AmenitiesUpdateInput; where: AmenitiesWhereUniqueInput }
  ) => AmenitiesPromise;
  updateManyAmenitieses: (
    args: {
      data: AmenitiesUpdateManyMutationInput;
      where?: AmenitiesWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAmenities: (
    args: {
      where: AmenitiesWhereUniqueInput;
      create: AmenitiesCreateInput;
      update: AmenitiesUpdateInput;
    }
  ) => AmenitiesPromise;
  deleteAmenities: (where: AmenitiesWhereUniqueInput) => AmenitiesPromise;
  deleteManyAmenitieses: (where?: AmenitiesWhereInput) => BatchPayloadPromise;
  createBooking: (data: BookingCreateInput) => BookingPromise;
  updateBooking: (
    args: { data: BookingUpdateInput; where: BookingWhereUniqueInput }
  ) => BookingPromise;
  updateManyBookings: (
    args: { data: BookingUpdateManyMutationInput; where?: BookingWhereInput }
  ) => BatchPayloadPromise;
  upsertBooking: (
    args: {
      where: BookingWhereUniqueInput;
      create: BookingCreateInput;
      update: BookingUpdateInput;
    }
  ) => BookingPromise;
  deleteBooking: (where: BookingWhereUniqueInput) => BookingPromise;
  deleteManyBookings: (where?: BookingWhereInput) => BatchPayloadPromise;
  createCity: (data: CityCreateInput) => CityPromise;
  updateCity: (
    args: { data: CityUpdateInput; where: CityWhereUniqueInput }
  ) => CityPromise;
  updateManyCities: (
    args: { data: CityUpdateManyMutationInput; where?: CityWhereInput }
  ) => BatchPayloadPromise;
  upsertCity: (
    args: {
      where: CityWhereUniqueInput;
      create: CityCreateInput;
      update: CityUpdateInput;
    }
  ) => CityPromise;
  deleteCity: (where: CityWhereUniqueInput) => CityPromise;
  deleteManyCities: (where?: CityWhereInput) => BatchPayloadPromise;
  createCreditCardInformation: (
    data: CreditCardInformationCreateInput
  ) => CreditCardInformationPromise;
  updateCreditCardInformation: (
    args: {
      data: CreditCardInformationUpdateInput;
      where: CreditCardInformationWhereUniqueInput;
    }
  ) => CreditCardInformationPromise;
  updateManyCreditCardInformations: (
    args: {
      data: CreditCardInformationUpdateManyMutationInput;
      where?: CreditCardInformationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCreditCardInformation: (
    args: {
      where: CreditCardInformationWhereUniqueInput;
      create: CreditCardInformationCreateInput;
      update: CreditCardInformationUpdateInput;
    }
  ) => CreditCardInformationPromise;
  deleteCreditCardInformation: (
    where: CreditCardInformationWhereUniqueInput
  ) => CreditCardInformationPromise;
  deleteManyCreditCardInformations: (
    where?: CreditCardInformationWhereInput
  ) => BatchPayloadPromise;
  createExperience: (data: ExperienceCreateInput) => ExperiencePromise;
  updateExperience: (
    args: { data: ExperienceUpdateInput; where: ExperienceWhereUniqueInput }
  ) => ExperiencePromise;
  updateManyExperiences: (
    args: {
      data: ExperienceUpdateManyMutationInput;
      where?: ExperienceWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertExperience: (
    args: {
      where: ExperienceWhereUniqueInput;
      create: ExperienceCreateInput;
      update: ExperienceUpdateInput;
    }
  ) => ExperiencePromise;
  deleteExperience: (where: ExperienceWhereUniqueInput) => ExperiencePromise;
  deleteManyExperiences: (where?: ExperienceWhereInput) => BatchPayloadPromise;
  createExperienceCategory: (
    data: ExperienceCategoryCreateInput
  ) => ExperienceCategoryPromise;
  updateExperienceCategory: (
    args: {
      data: ExperienceCategoryUpdateInput;
      where: ExperienceCategoryWhereUniqueInput;
    }
  ) => ExperienceCategoryPromise;
  updateManyExperienceCategories: (
    args: {
      data: ExperienceCategoryUpdateManyMutationInput;
      where?: ExperienceCategoryWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertExperienceCategory: (
    args: {
      where: ExperienceCategoryWhereUniqueInput;
      create: ExperienceCategoryCreateInput;
      update: ExperienceCategoryUpdateInput;
    }
  ) => ExperienceCategoryPromise;
  deleteExperienceCategory: (
    where: ExperienceCategoryWhereUniqueInput
  ) => ExperienceCategoryPromise;
  deleteManyExperienceCategories: (
    where?: ExperienceCategoryWhereInput
  ) => BatchPayloadPromise;
  createGuestRequirements: (
    data: GuestRequirementsCreateInput
  ) => GuestRequirementsPromise;
  updateGuestRequirements: (
    args: {
      data: GuestRequirementsUpdateInput;
      where: GuestRequirementsWhereUniqueInput;
    }
  ) => GuestRequirementsPromise;
  updateManyGuestRequirementses: (
    args: {
      data: GuestRequirementsUpdateManyMutationInput;
      where?: GuestRequirementsWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertGuestRequirements: (
    args: {
      where: GuestRequirementsWhereUniqueInput;
      create: GuestRequirementsCreateInput;
      update: GuestRequirementsUpdateInput;
    }
  ) => GuestRequirementsPromise;
  deleteGuestRequirements: (
    where: GuestRequirementsWhereUniqueInput
  ) => GuestRequirementsPromise;
  deleteManyGuestRequirementses: (
    where?: GuestRequirementsWhereInput
  ) => BatchPayloadPromise;
  createHouseRules: (data: HouseRulesCreateInput) => HouseRulesPromise;
  updateHouseRules: (
    args: { data: HouseRulesUpdateInput; where: HouseRulesWhereUniqueInput }
  ) => HouseRulesPromise;
  updateManyHouseRuleses: (
    args: {
      data: HouseRulesUpdateManyMutationInput;
      where?: HouseRulesWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertHouseRules: (
    args: {
      where: HouseRulesWhereUniqueInput;
      create: HouseRulesCreateInput;
      update: HouseRulesUpdateInput;
    }
  ) => HouseRulesPromise;
  deleteHouseRules: (where: HouseRulesWhereUniqueInput) => HouseRulesPromise;
  deleteManyHouseRuleses: (where?: HouseRulesWhereInput) => BatchPayloadPromise;
  createLocation: (data: LocationCreateInput) => LocationPromise;
  updateLocation: (
    args: { data: LocationUpdateInput; where: LocationWhereUniqueInput }
  ) => LocationPromise;
  updateManyLocations: (
    args: { data: LocationUpdateManyMutationInput; where?: LocationWhereInput }
  ) => BatchPayloadPromise;
  upsertLocation: (
    args: {
      where: LocationWhereUniqueInput;
      create: LocationCreateInput;
      update: LocationUpdateInput;
    }
  ) => LocationPromise;
  deleteLocation: (where: LocationWhereUniqueInput) => LocationPromise;
  deleteManyLocations: (where?: LocationWhereInput) => BatchPayloadPromise;
  createMessage: (data: MessageCreateInput) => MessagePromise;
  updateMessage: (
    args: { data: MessageUpdateInput; where: MessageWhereUniqueInput }
  ) => MessagePromise;
  updateManyMessages: (
    args: { data: MessageUpdateManyMutationInput; where?: MessageWhereInput }
  ) => BatchPayloadPromise;
  upsertMessage: (
    args: {
      where: MessageWhereUniqueInput;
      create: MessageCreateInput;
      update: MessageUpdateInput;
    }
  ) => MessagePromise;
  deleteMessage: (where: MessageWhereUniqueInput) => MessagePromise;
  deleteManyMessages: (where?: MessageWhereInput) => BatchPayloadPromise;
  createNeighbourhood: (data: NeighbourhoodCreateInput) => NeighbourhoodPromise;
  updateNeighbourhood: (
    args: {
      data: NeighbourhoodUpdateInput;
      where: NeighbourhoodWhereUniqueInput;
    }
  ) => NeighbourhoodPromise;
  updateManyNeighbourhoods: (
    args: {
      data: NeighbourhoodUpdateManyMutationInput;
      where?: NeighbourhoodWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertNeighbourhood: (
    args: {
      where: NeighbourhoodWhereUniqueInput;
      create: NeighbourhoodCreateInput;
      update: NeighbourhoodUpdateInput;
    }
  ) => NeighbourhoodPromise;
  deleteNeighbourhood: (
    where: NeighbourhoodWhereUniqueInput
  ) => NeighbourhoodPromise;
  deleteManyNeighbourhoods: (
    where?: NeighbourhoodWhereInput
  ) => BatchPayloadPromise;
  createNotification: (data: NotificationCreateInput) => NotificationPromise;
  updateNotification: (
    args: { data: NotificationUpdateInput; where: NotificationWhereUniqueInput }
  ) => NotificationPromise;
  updateManyNotifications: (
    args: {
      data: NotificationUpdateManyMutationInput;
      where?: NotificationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertNotification: (
    args: {
      where: NotificationWhereUniqueInput;
      create: NotificationCreateInput;
      update: NotificationUpdateInput;
    }
  ) => NotificationPromise;
  deleteNotification: (
    where: NotificationWhereUniqueInput
  ) => NotificationPromise;
  deleteManyNotifications: (
    where?: NotificationWhereInput
  ) => BatchPayloadPromise;
  createPayment: (data: PaymentCreateInput) => PaymentPromise;
  updatePayment: (
    args: { data: PaymentUpdateInput; where: PaymentWhereUniqueInput }
  ) => PaymentPromise;
  updateManyPayments: (
    args: { data: PaymentUpdateManyMutationInput; where?: PaymentWhereInput }
  ) => BatchPayloadPromise;
  upsertPayment: (
    args: {
      where: PaymentWhereUniqueInput;
      create: PaymentCreateInput;
      update: PaymentUpdateInput;
    }
  ) => PaymentPromise;
  deletePayment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  deleteManyPayments: (where?: PaymentWhereInput) => BatchPayloadPromise;
  createPaymentAccount: (
    data: PaymentAccountCreateInput
  ) => PaymentAccountPromise;
  updatePaymentAccount: (
    args: {
      data: PaymentAccountUpdateInput;
      where: PaymentAccountWhereUniqueInput;
    }
  ) => PaymentAccountPromise;
  updateManyPaymentAccounts: (
    args: {
      data: PaymentAccountUpdateManyMutationInput;
      where?: PaymentAccountWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPaymentAccount: (
    args: {
      where: PaymentAccountWhereUniqueInput;
      create: PaymentAccountCreateInput;
      update: PaymentAccountUpdateInput;
    }
  ) => PaymentAccountPromise;
  deletePaymentAccount: (
    where: PaymentAccountWhereUniqueInput
  ) => PaymentAccountPromise;
  deleteManyPaymentAccounts: (
    where?: PaymentAccountWhereInput
  ) => BatchPayloadPromise;
  createPaypalInformation: (
    data: PaypalInformationCreateInput
  ) => PaypalInformationPromise;
  updatePaypalInformation: (
    args: {
      data: PaypalInformationUpdateInput;
      where: PaypalInformationWhereUniqueInput;
    }
  ) => PaypalInformationPromise;
  updateManyPaypalInformations: (
    args: {
      data: PaypalInformationUpdateManyMutationInput;
      where?: PaypalInformationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPaypalInformation: (
    args: {
      where: PaypalInformationWhereUniqueInput;
      create: PaypalInformationCreateInput;
      update: PaypalInformationUpdateInput;
    }
  ) => PaypalInformationPromise;
  deletePaypalInformation: (
    where: PaypalInformationWhereUniqueInput
  ) => PaypalInformationPromise;
  deleteManyPaypalInformations: (
    where?: PaypalInformationWhereInput
  ) => BatchPayloadPromise;
  createPicture: (data: PictureCreateInput) => PicturePromise;
  updatePicture: (
    args: { data: PictureUpdateInput; where: PictureWhereUniqueInput }
  ) => PicturePromise;
  updateManyPictures: (
    args: { data: PictureUpdateManyMutationInput; where?: PictureWhereInput }
  ) => BatchPayloadPromise;
  upsertPicture: (
    args: {
      where: PictureWhereUniqueInput;
      create: PictureCreateInput;
      update: PictureUpdateInput;
    }
  ) => PicturePromise;
  deletePicture: (where: PictureWhereUniqueInput) => PicturePromise;
  deleteManyPictures: (where?: PictureWhereInput) => BatchPayloadPromise;
  createPlace: (data: PlaceCreateInput) => PlacePromise;
  updatePlace: (
    args: { data: PlaceUpdateInput; where: PlaceWhereUniqueInput }
  ) => PlacePromise;
  updateManyPlaces: (
    args: { data: PlaceUpdateManyMutationInput; where?: PlaceWhereInput }
  ) => BatchPayloadPromise;
  upsertPlace: (
    args: {
      where: PlaceWhereUniqueInput;
      create: PlaceCreateInput;
      update: PlaceUpdateInput;
    }
  ) => PlacePromise;
  deletePlace: (where: PlaceWhereUniqueInput) => PlacePromise;
  deleteManyPlaces: (where?: PlaceWhereInput) => BatchPayloadPromise;
  createPolicies: (data: PoliciesCreateInput) => PoliciesPromise;
  updatePolicies: (
    args: { data: PoliciesUpdateInput; where: PoliciesWhereUniqueInput }
  ) => PoliciesPromise;
  updateManyPolicieses: (
    args: { data: PoliciesUpdateManyMutationInput; where?: PoliciesWhereInput }
  ) => BatchPayloadPromise;
  upsertPolicies: (
    args: {
      where: PoliciesWhereUniqueInput;
      create: PoliciesCreateInput;
      update: PoliciesUpdateInput;
    }
  ) => PoliciesPromise;
  deletePolicies: (where: PoliciesWhereUniqueInput) => PoliciesPromise;
  deleteManyPolicieses: (where?: PoliciesWhereInput) => BatchPayloadPromise;
  createPricing: (data: PricingCreateInput) => PricingPromise;
  updatePricing: (
    args: { data: PricingUpdateInput; where: PricingWhereUniqueInput }
  ) => PricingPromise;
  updateManyPricings: (
    args: { data: PricingUpdateManyMutationInput; where?: PricingWhereInput }
  ) => BatchPayloadPromise;
  upsertPricing: (
    args: {
      where: PricingWhereUniqueInput;
      create: PricingCreateInput;
      update: PricingUpdateInput;
    }
  ) => PricingPromise;
  deletePricing: (where: PricingWhereUniqueInput) => PricingPromise;
  deleteManyPricings: (where?: PricingWhereInput) => BatchPayloadPromise;
  createRestaurant: (data: RestaurantCreateInput) => RestaurantPromise;
  updateRestaurant: (
    args: { data: RestaurantUpdateInput; where: RestaurantWhereUniqueInput }
  ) => RestaurantPromise;
  updateManyRestaurants: (
    args: {
      data: RestaurantUpdateManyMutationInput;
      where?: RestaurantWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertRestaurant: (
    args: {
      where: RestaurantWhereUniqueInput;
      create: RestaurantCreateInput;
      update: RestaurantUpdateInput;
    }
  ) => RestaurantPromise;
  deleteRestaurant: (where: RestaurantWhereUniqueInput) => RestaurantPromise;
  deleteManyRestaurants: (where?: RestaurantWhereInput) => BatchPayloadPromise;
  createReview: (data: ReviewCreateInput) => ReviewPromise;
  updateReview: (
    args: { data: ReviewUpdateInput; where: ReviewWhereUniqueInput }
  ) => ReviewPromise;
  updateManyReviews: (
    args: { data: ReviewUpdateManyMutationInput; where?: ReviewWhereInput }
  ) => BatchPayloadPromise;
  upsertReview: (
    args: {
      where: ReviewWhereUniqueInput;
      create: ReviewCreateInput;
      update: ReviewUpdateInput;
    }
  ) => ReviewPromise;
  deleteReview: (where: ReviewWhereUniqueInput) => ReviewPromise;
  deleteManyReviews: (where?: ReviewWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createViews: (data: ViewsCreateInput) => ViewsPromise;
  updateViews: (
    args: { data: ViewsUpdateInput; where: ViewsWhereUniqueInput }
  ) => ViewsPromise;
  updateManyViewses: (
    args: { data: ViewsUpdateManyMutationInput; where?: ViewsWhereInput }
  ) => BatchPayloadPromise;
  upsertViews: (
    args: {
      where: ViewsWhereUniqueInput;
      create: ViewsCreateInput;
      update: ViewsUpdateInput;
    }
  ) => ViewsPromise;
  deleteViews: (where: ViewsWhereUniqueInput) => ViewsPromise;
  deleteManyViewses: (where?: ViewsWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  amenities: (
    where?: AmenitiesSubscriptionWhereInput
  ) => AmenitiesSubscriptionPayloadSubscription;
  booking: (
    where?: BookingSubscriptionWhereInput
  ) => BookingSubscriptionPayloadSubscription;
  city: (
    where?: CitySubscriptionWhereInput
  ) => CitySubscriptionPayloadSubscription;
  creditCardInformation: (
    where?: CreditCardInformationSubscriptionWhereInput
  ) => CreditCardInformationSubscriptionPayloadSubscription;
  experience: (
    where?: ExperienceSubscriptionWhereInput
  ) => ExperienceSubscriptionPayloadSubscription;
  experienceCategory: (
    where?: ExperienceCategorySubscriptionWhereInput
  ) => ExperienceCategorySubscriptionPayloadSubscription;
  guestRequirements: (
    where?: GuestRequirementsSubscriptionWhereInput
  ) => GuestRequirementsSubscriptionPayloadSubscription;
  houseRules: (
    where?: HouseRulesSubscriptionWhereInput
  ) => HouseRulesSubscriptionPayloadSubscription;
  location: (
    where?: LocationSubscriptionWhereInput
  ) => LocationSubscriptionPayloadSubscription;
  message: (
    where?: MessageSubscriptionWhereInput
  ) => MessageSubscriptionPayloadSubscription;
  neighbourhood: (
    where?: NeighbourhoodSubscriptionWhereInput
  ) => NeighbourhoodSubscriptionPayloadSubscription;
  notification: (
    where?: NotificationSubscriptionWhereInput
  ) => NotificationSubscriptionPayloadSubscription;
  payment: (
    where?: PaymentSubscriptionWhereInput
  ) => PaymentSubscriptionPayloadSubscription;
  paymentAccount: (
    where?: PaymentAccountSubscriptionWhereInput
  ) => PaymentAccountSubscriptionPayloadSubscription;
  paypalInformation: (
    where?: PaypalInformationSubscriptionWhereInput
  ) => PaypalInformationSubscriptionPayloadSubscription;
  picture: (
    where?: PictureSubscriptionWhereInput
  ) => PictureSubscriptionPayloadSubscription;
  place: (
    where?: PlaceSubscriptionWhereInput
  ) => PlaceSubscriptionPayloadSubscription;
  policies: (
    where?: PoliciesSubscriptionWhereInput
  ) => PoliciesSubscriptionPayloadSubscription;
  pricing: (
    where?: PricingSubscriptionWhereInput
  ) => PricingSubscriptionPayloadSubscription;
  restaurant: (
    where?: RestaurantSubscriptionWhereInput
  ) => RestaurantSubscriptionPayloadSubscription;
  review: (
    where?: ReviewSubscriptionWhereInput
  ) => ReviewSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  views: (
    where?: ViewsSubscriptionWhereInput
  ) => ViewsSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AmenitiesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "elevator_ASC"
  | "elevator_DESC"
  | "petsAllowed_ASC"
  | "petsAllowed_DESC"
  | "internet_ASC"
  | "internet_DESC"
  | "kitchen_ASC"
  | "kitchen_DESC"
  | "wirelessInternet_ASC"
  | "wirelessInternet_DESC"
  | "familyKidFriendly_ASC"
  | "familyKidFriendly_DESC"
  | "freeParkingOnPremises_ASC"
  | "freeParkingOnPremises_DESC"
  | "hotTub_ASC"
  | "hotTub_DESC"
  | "pool_ASC"
  | "pool_DESC"
  | "smokingAllowed_ASC"
  | "smokingAllowed_DESC"
  | "wheelchairAccessible_ASC"
  | "wheelchairAccessible_DESC"
  | "breakfast_ASC"
  | "breakfast_DESC"
  | "cableTv_ASC"
  | "cableTv_DESC"
  | "suitableForEvents_ASC"
  | "suitableForEvents_DESC"
  | "dryer_ASC"
  | "dryer_DESC"
  | "washer_ASC"
  | "washer_DESC"
  | "indoorFireplace_ASC"
  | "indoorFireplace_DESC"
  | "tv_ASC"
  | "tv_DESC"
  | "heating_ASC"
  | "heating_DESC"
  | "hangers_ASC"
  | "hangers_DESC"
  | "iron_ASC"
  | "iron_DESC"
  | "hairDryer_ASC"
  | "hairDryer_DESC"
  | "doorman_ASC"
  | "doorman_DESC"
  | "paidParkingOffPremises_ASC"
  | "paidParkingOffPremises_DESC"
  | "freeParkingOnStreet_ASC"
  | "freeParkingOnStreet_DESC"
  | "gym_ASC"
  | "gym_DESC"
  | "airConditioning_ASC"
  | "airConditioning_DESC"
  | "shampoo_ASC"
  | "shampoo_DESC"
  | "essentials_ASC"
  | "essentials_DESC"
  | "laptopFriendlyWorkspace_ASC"
  | "laptopFriendlyWorkspace_DESC"
  | "privateEntrance_ASC"
  | "privateEntrance_DESC"
  | "buzzerWirelessIntercom_ASC"
  | "buzzerWirelessIntercom_DESC"
  | "babyBath_ASC"
  | "babyBath_DESC"
  | "babyMonitor_ASC"
  | "babyMonitor_DESC"
  | "babysitterRecommendations_ASC"
  | "babysitterRecommendations_DESC"
  | "bathtub_ASC"
  | "bathtub_DESC"
  | "changingTable_ASC"
  | "changingTable_DESC"
  | "childrensBooksAndToys_ASC"
  | "childrensBooksAndToys_DESC"
  | "childrensDinnerware_ASC"
  | "childrensDinnerware_DESC"
  | "crib_ASC"
  | "crib_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NOTIFICATION_TYPE =
  | "OFFER"
  | "INSTANT_BOOK"
  | "RESPONSIVENESS"
  | "NEW_AMENITIES"
  | "HOUSE_RULES";

export type ExperienceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "pricePerPerson_ASC"
  | "pricePerPerson_DESC"
  | "popularity_ASC"
  | "popularity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ViewsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "lastWeek_ASC"
  | "lastWeek_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NotificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "link_ASC"
  | "link_DESC"
  | "readDate_ASC"
  | "readDate_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PLACE_SIZES =
  | "ENTIRE_HOUSE"
  | "ENTIRE_APARTMENT"
  | "ENTIRE_EARTH_HOUSE"
  | "ENTIRE_CABIN"
  | "ENTIRE_VILLA"
  | "ENTIRE_PLACE"
  | "ENTIRE_BOAT"
  | "PRIVATE_ROOM";

export type MessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "deliveredAt_ASC"
  | "deliveredAt_DESC"
  | "readAt_ASC"
  | "readAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PricingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "monthlyDiscount_ASC"
  | "monthlyDiscount_DESC"
  | "weeklyDiscount_ASC"
  | "weeklyDiscount_DESC"
  | "perNight_ASC"
  | "perNight_DESC"
  | "smartPricing_ASC"
  | "smartPricing_DESC"
  | "basePrice_ASC"
  | "basePrice_DESC"
  | "averageWeekly_ASC"
  | "averageWeekly_DESC"
  | "averageMonthly_ASC"
  | "averageMonthly_DESC"
  | "cleaningFee_ASC"
  | "cleaningFee_DESC"
  | "securityDeposit_ASC"
  | "securityDeposit_DESC"
  | "extraGuests_ASC"
  | "extraGuests_DESC"
  | "weekendPricing_ASC"
  | "weekendPricing_DESC"
  | "currency_ASC"
  | "currency_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PaymentAccountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PaypalInformationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PaymentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "serviceFee_ASC"
  | "serviceFee_DESC"
  | "placePrice_ASC"
  | "placePrice_DESC"
  | "totalPrice_ASC"
  | "totalPrice_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GuestRequirementsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "govIssuedId_ASC"
  | "govIssuedId_DESC"
  | "recommendationsFromOtherHosts_ASC"
  | "recommendationsFromOtherHosts_DESC"
  | "guestTripInformation_ASC"
  | "guestTripInformation_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BookingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CreditCardInformationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "cardNumber_ASC"
  | "cardNumber_DESC"
  | "expiresOnMonth_ASC"
  | "expiresOnMonth_DESC"
  | "expiresOnYear_ASC"
  | "expiresOnYear_DESC"
  | "securityCode_ASC"
  | "securityCode_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "postalCode_ASC"
  | "postalCode_DESC"
  | "country_ASC"
  | "country_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PictureOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "url_ASC"
  | "url_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type NeighbourhoodOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "featured_ASC"
  | "featured_DESC"
  | "popularity_ASC"
  | "popularity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RestaurantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "avgPricePerPerson_ASC"
  | "avgPricePerPerson_DESC"
  | "isCurated_ASC"
  | "isCurated_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "popularity_ASC"
  | "popularity_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PAYMENT_PROVIDER = "PAYPAL" | "CREDIT_CARD";

export type HouseRulesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "suitableForChildren_ASC"
  | "suitableForChildren_DESC"
  | "suitableForInfants_ASC"
  | "suitableForInfants_DESC"
  | "petsAllowed_ASC"
  | "petsAllowed_DESC"
  | "smokingAllowed_ASC"
  | "smokingAllowed_DESC"
  | "partiesAndEventsAllowed_ASC"
  | "partiesAndEventsAllowed_DESC"
  | "additionalRules_ASC"
  | "additionalRules_DESC";

export type CURRENCY = "CAD" | "CHF" | "EUR" | "JPY" | "USD" | "ZAR";

export type ReviewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "text_ASC"
  | "text_DESC"
  | "stars_ASC"
  | "stars_DESC"
  | "accuracy_ASC"
  | "accuracy_DESC"
  | "location_ASC"
  | "location_DESC"
  | "checkIn_ASC"
  | "checkIn_DESC"
  | "value_ASC"
  | "value_DESC"
  | "cleanliness_ASC"
  | "cleanliness_DESC"
  | "communication_ASC"
  | "communication_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PlaceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "size_ASC"
  | "size_DESC"
  | "shortDescription_ASC"
  | "shortDescription_DESC"
  | "description_ASC"
  | "description_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "maxGuests_ASC"
  | "maxGuests_DESC"
  | "numBedrooms_ASC"
  | "numBedrooms_DESC"
  | "numBeds_ASC"
  | "numBeds_DESC"
  | "numBaths_ASC"
  | "numBaths_DESC"
  | "popularity_ASC"
  | "popularity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LocationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "lat_ASC"
  | "lat_DESC"
  | "lng_ASC"
  | "lng_DESC"
  | "address_ASC"
  | "address_DESC"
  | "directions_ASC"
  | "directions_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExperienceCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "mainColor_ASC"
  | "mainColor_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PoliciesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "checkInStartTime_ASC"
  | "checkInStartTime_DESC"
  | "checkInEndTime_ASC"
  | "checkInEndTime_DESC"
  | "checkoutTime_ASC"
  | "checkoutTime_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "responseRate_ASC"
  | "responseRate_DESC"
  | "responseTime_ASC"
  | "responseTime_DESC"
  | "isSuperHost_ASC"
  | "isSuperHost_DESC";

export type CityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface PlaceUpdateWithoutBookingsDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneRequiredWithoutPlaceInput;
  host?: UserUpdateOneRequiredWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneRequiredWithoutPlaceInput;
  location?: LocationUpdateOneRequiredWithoutPlaceInput;
  views?: ViewsUpdateOneRequiredWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export type AmenitiesWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PoliciesUpsertWithoutPlaceInput {
  update: PoliciesUpdateWithoutPlaceDataInput;
  create: PoliciesCreateWithoutPlaceInput;
}

export interface PricingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  place?: PlaceWhereInput;
  monthlyDiscount?: Int;
  monthlyDiscount_not?: Int;
  monthlyDiscount_in?: Int[] | Int;
  monthlyDiscount_not_in?: Int[] | Int;
  monthlyDiscount_lt?: Int;
  monthlyDiscount_lte?: Int;
  monthlyDiscount_gt?: Int;
  monthlyDiscount_gte?: Int;
  weeklyDiscount?: Int;
  weeklyDiscount_not?: Int;
  weeklyDiscount_in?: Int[] | Int;
  weeklyDiscount_not_in?: Int[] | Int;
  weeklyDiscount_lt?: Int;
  weeklyDiscount_lte?: Int;
  weeklyDiscount_gt?: Int;
  weeklyDiscount_gte?: Int;
  perNight?: Int;
  perNight_not?: Int;
  perNight_in?: Int[] | Int;
  perNight_not_in?: Int[] | Int;
  perNight_lt?: Int;
  perNight_lte?: Int;
  perNight_gt?: Int;
  perNight_gte?: Int;
  smartPricing?: Boolean;
  smartPricing_not?: Boolean;
  basePrice?: Int;
  basePrice_not?: Int;
  basePrice_in?: Int[] | Int;
  basePrice_not_in?: Int[] | Int;
  basePrice_lt?: Int;
  basePrice_lte?: Int;
  basePrice_gt?: Int;
  basePrice_gte?: Int;
  averageWeekly?: Int;
  averageWeekly_not?: Int;
  averageWeekly_in?: Int[] | Int;
  averageWeekly_not_in?: Int[] | Int;
  averageWeekly_lt?: Int;
  averageWeekly_lte?: Int;
  averageWeekly_gt?: Int;
  averageWeekly_gte?: Int;
  averageMonthly?: Int;
  averageMonthly_not?: Int;
  averageMonthly_in?: Int[] | Int;
  averageMonthly_not_in?: Int[] | Int;
  averageMonthly_lt?: Int;
  averageMonthly_lte?: Int;
  averageMonthly_gt?: Int;
  averageMonthly_gte?: Int;
  cleaningFee?: Int;
  cleaningFee_not?: Int;
  cleaningFee_in?: Int[] | Int;
  cleaningFee_not_in?: Int[] | Int;
  cleaningFee_lt?: Int;
  cleaningFee_lte?: Int;
  cleaningFee_gt?: Int;
  cleaningFee_gte?: Int;
  securityDeposit?: Int;
  securityDeposit_not?: Int;
  securityDeposit_in?: Int[] | Int;
  securityDeposit_not_in?: Int[] | Int;
  securityDeposit_lt?: Int;
  securityDeposit_lte?: Int;
  securityDeposit_gt?: Int;
  securityDeposit_gte?: Int;
  extraGuests?: Int;
  extraGuests_not?: Int;
  extraGuests_in?: Int[] | Int;
  extraGuests_not_in?: Int[] | Int;
  extraGuests_lt?: Int;
  extraGuests_lte?: Int;
  extraGuests_gt?: Int;
  extraGuests_gte?: Int;
  weekendPricing?: Int;
  weekendPricing_not?: Int;
  weekendPricing_in?: Int[] | Int;
  weekendPricing_not_in?: Int[] | Int;
  weekendPricing_lt?: Int;
  weekendPricing_lte?: Int;
  weekendPricing_gt?: Int;
  weekendPricing_gte?: Int;
  currency?: CURRENCY;
  currency_not?: CURRENCY;
  currency_in?: CURRENCY[] | CURRENCY;
  currency_not_in?: CURRENCY[] | CURRENCY;
  AND?: PricingWhereInput[] | PricingWhereInput;
  OR?: PricingWhereInput[] | PricingWhereInput;
  NOT?: PricingWhereInput[] | PricingWhereInput;
}

export interface HouseRulesUpdateOneInput {
  create?: HouseRulesCreateInput;
  update?: HouseRulesUpdateDataInput;
  upsert?: HouseRulesUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: HouseRulesWhereUniqueInput;
}

export interface ViewsWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  lastWeek?: Int;
  lastWeek_not?: Int;
  lastWeek_in?: Int[] | Int;
  lastWeek_not_in?: Int[] | Int;
  lastWeek_lt?: Int;
  lastWeek_lte?: Int;
  lastWeek_gt?: Int;
  lastWeek_gte?: Int;
  place?: PlaceWhereInput;
  AND?: ViewsWhereInput[] | ViewsWhereInput;
  OR?: ViewsWhereInput[] | ViewsWhereInput;
  NOT?: ViewsWhereInput[] | ViewsWhereInput;
}

export interface HouseRulesUpdateDataInput {
  suitableForChildren?: Boolean;
  suitableForInfants?: Boolean;
  petsAllowed?: Boolean;
  smokingAllowed?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  additionalRules?: String;
}

export interface PoliciesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  checkInStartTime?: Float;
  checkInStartTime_not?: Float;
  checkInStartTime_in?: Float[] | Float;
  checkInStartTime_not_in?: Float[] | Float;
  checkInStartTime_lt?: Float;
  checkInStartTime_lte?: Float;
  checkInStartTime_gt?: Float;
  checkInStartTime_gte?: Float;
  checkInEndTime?: Float;
  checkInEndTime_not?: Float;
  checkInEndTime_in?: Float[] | Float;
  checkInEndTime_not_in?: Float[] | Float;
  checkInEndTime_lt?: Float;
  checkInEndTime_lte?: Float;
  checkInEndTime_gt?: Float;
  checkInEndTime_gte?: Float;
  checkoutTime?: Float;
  checkoutTime_not?: Float;
  checkoutTime_in?: Float[] | Float;
  checkoutTime_not_in?: Float[] | Float;
  checkoutTime_lt?: Float;
  checkoutTime_lte?: Float;
  checkoutTime_gt?: Float;
  checkoutTime_gte?: Float;
  place?: PlaceWhereInput;
  AND?: PoliciesWhereInput[] | PoliciesWhereInput;
  OR?: PoliciesWhereInput[] | PoliciesWhereInput;
  NOT?: PoliciesWhereInput[] | PoliciesWhereInput;
}

export interface HouseRulesUpsertNestedInput {
  update: HouseRulesUpdateDataInput;
  create: HouseRulesCreateInput;
}

export interface MessageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  from?: UserWhereInput;
  to?: UserWhereInput;
  deliveredAt?: DateTimeInput;
  deliveredAt_not?: DateTimeInput;
  deliveredAt_in?: DateTimeInput[] | DateTimeInput;
  deliveredAt_not_in?: DateTimeInput[] | DateTimeInput;
  deliveredAt_lt?: DateTimeInput;
  deliveredAt_lte?: DateTimeInput;
  deliveredAt_gt?: DateTimeInput;
  deliveredAt_gte?: DateTimeInput;
  readAt?: DateTimeInput;
  readAt_not?: DateTimeInput;
  readAt_in?: DateTimeInput[] | DateTimeInput;
  readAt_not_in?: DateTimeInput[] | DateTimeInput;
  readAt_lt?: DateTimeInput;
  readAt_lte?: DateTimeInput;
  readAt_gt?: DateTimeInput;
  readAt_gte?: DateTimeInput;
  AND?: MessageWhereInput[] | MessageWhereInput;
  OR?: MessageWhereInput[] | MessageWhereInput;
  NOT?: MessageWhereInput[] | MessageWhereInput;
}

export interface ReviewCreateWithoutExperienceInput {
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
  place: PlaceCreateOneWithoutReviewsInput;
}

export interface GuestRequirementsUpdateManyMutationInput {
  govIssuedId?: Boolean;
  recommendationsFromOtherHosts?: Boolean;
  guestTripInformation?: Boolean;
}

export interface PlaceCreateOneWithoutReviewsInput {
  create?: PlaceCreateWithoutReviewsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface BookingUpdateManyWithoutPlaceInput {
  create?: BookingCreateWithoutPlaceInput[] | BookingCreateWithoutPlaceInput;
  delete?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  disconnect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  update?:
    | BookingUpdateWithWhereUniqueWithoutPlaceInput[]
    | BookingUpdateWithWhereUniqueWithoutPlaceInput;
  upsert?:
    | BookingUpsertWithWhereUniqueWithoutPlaceInput[]
    | BookingUpsertWithWhereUniqueWithoutPlaceInput;
}

export interface PlaceCreateWithoutReviewsInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface CreditCardInformationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  cardNumber?: String;
  cardNumber_not?: String;
  cardNumber_in?: String[] | String;
  cardNumber_not_in?: String[] | String;
  cardNumber_lt?: String;
  cardNumber_lte?: String;
  cardNumber_gt?: String;
  cardNumber_gte?: String;
  cardNumber_contains?: String;
  cardNumber_not_contains?: String;
  cardNumber_starts_with?: String;
  cardNumber_not_starts_with?: String;
  cardNumber_ends_with?: String;
  cardNumber_not_ends_with?: String;
  expiresOnMonth?: Int;
  expiresOnMonth_not?: Int;
  expiresOnMonth_in?: Int[] | Int;
  expiresOnMonth_not_in?: Int[] | Int;
  expiresOnMonth_lt?: Int;
  expiresOnMonth_lte?: Int;
  expiresOnMonth_gt?: Int;
  expiresOnMonth_gte?: Int;
  expiresOnYear?: Int;
  expiresOnYear_not?: Int;
  expiresOnYear_in?: Int[] | Int;
  expiresOnYear_not_in?: Int[] | Int;
  expiresOnYear_lt?: Int;
  expiresOnYear_lte?: Int;
  expiresOnYear_gt?: Int;
  expiresOnYear_gte?: Int;
  securityCode?: String;
  securityCode_not?: String;
  securityCode_in?: String[] | String;
  securityCode_not_in?: String[] | String;
  securityCode_lt?: String;
  securityCode_lte?: String;
  securityCode_gt?: String;
  securityCode_gte?: String;
  securityCode_contains?: String;
  securityCode_not_contains?: String;
  securityCode_starts_with?: String;
  securityCode_not_starts_with?: String;
  securityCode_ends_with?: String;
  securityCode_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  postalCode?: String;
  postalCode_not?: String;
  postalCode_in?: String[] | String;
  postalCode_not_in?: String[] | String;
  postalCode_lt?: String;
  postalCode_lte?: String;
  postalCode_gt?: String;
  postalCode_gte?: String;
  postalCode_contains?: String;
  postalCode_not_contains?: String;
  postalCode_starts_with?: String;
  postalCode_not_starts_with?: String;
  postalCode_ends_with?: String;
  postalCode_not_ends_with?: String;
  country?: String;
  country_not?: String;
  country_in?: String[] | String;
  country_not_in?: String[] | String;
  country_lt?: String;
  country_lte?: String;
  country_gt?: String;
  country_gte?: String;
  country_contains?: String;
  country_not_contains?: String;
  country_starts_with?: String;
  country_not_starts_with?: String;
  country_ends_with?: String;
  country_not_ends_with?: String;
  paymentAccount?: PaymentAccountWhereInput;
  AND?: CreditCardInformationWhereInput[] | CreditCardInformationWhereInput;
  OR?: CreditCardInformationWhereInput[] | CreditCardInformationWhereInput;
  NOT?: CreditCardInformationWhereInput[] | CreditCardInformationWhereInput;
}

export interface MessageCreateManyWithoutToInput {
  create?: MessageCreateWithoutToInput[] | MessageCreateWithoutToInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
}

export interface ReviewSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ReviewWhereInput;
  AND?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput;
  OR?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput;
  NOT?: ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput;
}

export interface MessageCreateWithoutToInput {
  from: UserCreateOneWithoutSentMessagesInput;
  deliveredAt: DateTimeInput;
  readAt: DateTimeInput;
}

export interface RestaurantSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RestaurantWhereInput;
  AND?: RestaurantSubscriptionWhereInput[] | RestaurantSubscriptionWhereInput;
  OR?: RestaurantSubscriptionWhereInput[] | RestaurantSubscriptionWhereInput;
  NOT?: RestaurantSubscriptionWhereInput[] | RestaurantSubscriptionWhereInput;
}

export interface UserCreateOneWithoutSentMessagesInput {
  create?: UserCreateWithoutSentMessagesInput;
  connect?: UserWhereUniqueInput;
}

export interface PaymentAccountWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  type?: PAYMENT_PROVIDER;
  type_not?: PAYMENT_PROVIDER;
  type_in?: PAYMENT_PROVIDER[] | PAYMENT_PROVIDER;
  type_not_in?: PAYMENT_PROVIDER[] | PAYMENT_PROVIDER;
  user?: UserWhereInput;
  payments_every?: PaymentWhereInput;
  payments_some?: PaymentWhereInput;
  payments_none?: PaymentWhereInput;
  paypal?: PaypalInformationWhereInput;
  creditcard?: CreditCardInformationWhereInput;
  AND?: PaymentAccountWhereInput[] | PaymentAccountWhereInput;
  OR?: PaymentAccountWhereInput[] | PaymentAccountWhereInput;
  NOT?: PaymentAccountWhereInput[] | PaymentAccountWhereInput;
}

export interface UserCreateWithoutSentMessagesInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface PaymentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  serviceFee?: Float;
  serviceFee_not?: Float;
  serviceFee_in?: Float[] | Float;
  serviceFee_not_in?: Float[] | Float;
  serviceFee_lt?: Float;
  serviceFee_lte?: Float;
  serviceFee_gt?: Float;
  serviceFee_gte?: Float;
  placePrice?: Float;
  placePrice_not?: Float;
  placePrice_in?: Float[] | Float;
  placePrice_not_in?: Float[] | Float;
  placePrice_lt?: Float;
  placePrice_lte?: Float;
  placePrice_gt?: Float;
  placePrice_gte?: Float;
  totalPrice?: Float;
  totalPrice_not?: Float;
  totalPrice_in?: Float[] | Float;
  totalPrice_not_in?: Float[] | Float;
  totalPrice_lt?: Float;
  totalPrice_lte?: Float;
  totalPrice_gt?: Float;
  totalPrice_gte?: Float;
  booking?: BookingWhereInput;
  paymentMethod?: PaymentAccountWhereInput;
  AND?: PaymentWhereInput[] | PaymentWhereInput;
  OR?: PaymentWhereInput[] | PaymentWhereInput;
  NOT?: PaymentWhereInput[] | PaymentWhereInput;
}

export interface PaymentCreateOneWithoutBookingInput {
  create?: PaymentCreateWithoutBookingInput;
  connect?: PaymentWhereUniqueInput;
}

export interface PlaceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PlaceWhereInput;
  AND?: PlaceSubscriptionWhereInput[] | PlaceSubscriptionWhereInput;
  OR?: PlaceSubscriptionWhereInput[] | PlaceSubscriptionWhereInput;
  NOT?: PlaceSubscriptionWhereInput[] | PlaceSubscriptionWhereInput;
}

export interface PaymentCreateWithoutBookingInput {
  serviceFee: Float;
  placePrice: Float;
  totalPrice: Float;
  paymentMethod: PaymentAccountCreateOneWithoutPaymentsInput;
}

export interface PaypalInformationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PaypalInformationWhereInput;
  AND?:
    | PaypalInformationSubscriptionWhereInput[]
    | PaypalInformationSubscriptionWhereInput;
  OR?:
    | PaypalInformationSubscriptionWhereInput[]
    | PaypalInformationSubscriptionWhereInput;
  NOT?:
    | PaypalInformationSubscriptionWhereInput[]
    | PaypalInformationSubscriptionWhereInput;
}

export interface PaymentAccountCreateOneWithoutPaymentsInput {
  create?: PaymentAccountCreateWithoutPaymentsInput;
  connect?: PaymentAccountWhereUniqueInput;
}

export interface PaymentAccountSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PaymentAccountWhereInput;
  AND?:
    | PaymentAccountSubscriptionWhereInput[]
    | PaymentAccountSubscriptionWhereInput;
  OR?:
    | PaymentAccountSubscriptionWhereInput[]
    | PaymentAccountSubscriptionWhereInput;
  NOT?:
    | PaymentAccountSubscriptionWhereInput[]
    | PaymentAccountSubscriptionWhereInput;
}

export interface PaymentAccountCreateWithoutPaymentsInput {
  type?: PAYMENT_PROVIDER;
  user: UserCreateOneWithoutPaymentAccountInput;
  paypal?: PaypalInformationCreateOneWithoutPaymentAccountInput;
  creditcard?: CreditCardInformationCreateOneWithoutPaymentAccountInput;
}

export interface ExperienceCategoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  mainColor?: String;
  mainColor_not?: String;
  mainColor_in?: String[] | String;
  mainColor_not_in?: String[] | String;
  mainColor_lt?: String;
  mainColor_lte?: String;
  mainColor_gt?: String;
  mainColor_gte?: String;
  mainColor_contains?: String;
  mainColor_not_contains?: String;
  mainColor_starts_with?: String;
  mainColor_not_starts_with?: String;
  mainColor_ends_with?: String;
  mainColor_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  experience?: ExperienceWhereInput;
  AND?: ExperienceCategoryWhereInput[] | ExperienceCategoryWhereInput;
  OR?: ExperienceCategoryWhereInput[] | ExperienceCategoryWhereInput;
  NOT?: ExperienceCategoryWhereInput[] | ExperienceCategoryWhereInput;
}

export interface UserCreateOneWithoutPaymentAccountInput {
  create?: UserCreateWithoutPaymentAccountInput;
  connect?: UserWhereUniqueInput;
}

export interface NotificationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: NotificationWhereInput;
  AND?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
  OR?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
  NOT?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
}

export interface UserCreateWithoutPaymentAccountInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface NeighbourhoodSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: NeighbourhoodWhereInput;
  AND?:
    | NeighbourhoodSubscriptionWhereInput[]
    | NeighbourhoodSubscriptionWhereInput;
  OR?:
    | NeighbourhoodSubscriptionWhereInput[]
    | NeighbourhoodSubscriptionWhereInput;
  NOT?:
    | NeighbourhoodSubscriptionWhereInput[]
    | NeighbourhoodSubscriptionWhereInput;
}

export interface ExperienceCreateOneWithoutLocationInput {
  create?: ExperienceCreateWithoutLocationInput;
  connect?: ExperienceWhereUniqueInput;
}

export interface MessageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MessageWhereInput;
  AND?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
  OR?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
  NOT?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
}

export interface ExperienceCreateWithoutLocationInput {
  category?: ExperienceCategoryCreateOneWithoutExperienceInput;
  title: String;
  host: UserCreateOneWithoutHostingExperiencesInput;
  pricePerPerson: Int;
  reviews?: ReviewCreateManyWithoutExperienceInput;
  preview: PictureCreateOneInput;
  popularity: Int;
}

export interface HouseRulesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HouseRulesWhereInput;
  AND?: HouseRulesSubscriptionWhereInput[] | HouseRulesSubscriptionWhereInput;
  OR?: HouseRulesSubscriptionWhereInput[] | HouseRulesSubscriptionWhereInput;
  NOT?: HouseRulesSubscriptionWhereInput[] | HouseRulesSubscriptionWhereInput;
}

export interface AmenitiesUpdateInput {
  place?: PlaceUpdateOneRequiredWithoutAmenitiesInput;
  elevator?: Boolean;
  petsAllowed?: Boolean;
  internet?: Boolean;
  kitchen?: Boolean;
  wirelessInternet?: Boolean;
  familyKidFriendly?: Boolean;
  freeParkingOnPremises?: Boolean;
  hotTub?: Boolean;
  pool?: Boolean;
  smokingAllowed?: Boolean;
  wheelchairAccessible?: Boolean;
  breakfast?: Boolean;
  cableTv?: Boolean;
  suitableForEvents?: Boolean;
  dryer?: Boolean;
  washer?: Boolean;
  indoorFireplace?: Boolean;
  tv?: Boolean;
  heating?: Boolean;
  hangers?: Boolean;
  iron?: Boolean;
  hairDryer?: Boolean;
  doorman?: Boolean;
  paidParkingOffPremises?: Boolean;
  freeParkingOnStreet?: Boolean;
  gym?: Boolean;
  airConditioning?: Boolean;
  shampoo?: Boolean;
  essentials?: Boolean;
  laptopFriendlyWorkspace?: Boolean;
  privateEntrance?: Boolean;
  buzzerWirelessIntercom?: Boolean;
  babyBath?: Boolean;
  babyMonitor?: Boolean;
  babysitterRecommendations?: Boolean;
  bathtub?: Boolean;
  changingTable?: Boolean;
  childrensBooksAndToys?: Boolean;
  childrensDinnerware?: Boolean;
  crib?: Boolean;
}

export interface ExperienceCategorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExperienceCategoryWhereInput;
  AND?:
    | ExperienceCategorySubscriptionWhereInput[]
    | ExperienceCategorySubscriptionWhereInput;
  OR?:
    | ExperienceCategorySubscriptionWhereInput[]
    | ExperienceCategorySubscriptionWhereInput;
  NOT?:
    | ExperienceCategorySubscriptionWhereInput[]
    | ExperienceCategorySubscriptionWhereInput;
}

export interface PlaceUpdateOneRequiredWithoutAmenitiesInput {
  create?: PlaceCreateWithoutAmenitiesInput;
  update?: PlaceUpdateWithoutAmenitiesDataInput;
  upsert?: PlaceUpsertWithoutAmenitiesInput;
  connect?: PlaceWhereUniqueInput;
}

export interface ExperienceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExperienceWhereInput;
  AND?: ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput;
  OR?: ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput;
  NOT?: ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput;
}

export interface PlaceUpdateWithoutAmenitiesDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  host?: UserUpdateOneRequiredWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneRequiredWithoutPlaceInput;
  location?: LocationUpdateOneRequiredWithoutPlaceInput;
  views?: ViewsUpdateOneRequiredWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface CitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CityWhereInput;
  AND?: CitySubscriptionWhereInput[] | CitySubscriptionWhereInput;
  OR?: CitySubscriptionWhereInput[] | CitySubscriptionWhereInput;
  NOT?: CitySubscriptionWhereInput[] | CitySubscriptionWhereInput;
}

export interface ReviewUpdateManyWithoutPlaceInput {
  create?: ReviewCreateWithoutPlaceInput[] | ReviewCreateWithoutPlaceInput;
  delete?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  disconnect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  update?:
    | ReviewUpdateWithWhereUniqueWithoutPlaceInput[]
    | ReviewUpdateWithWhereUniqueWithoutPlaceInput;
  upsert?:
    | ReviewUpsertWithWhereUniqueWithoutPlaceInput[]
    | ReviewUpsertWithWhereUniqueWithoutPlaceInput;
}

export type BookingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ReviewUpdateWithWhereUniqueWithoutPlaceInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutPlaceDataInput;
}

export interface ViewsUpdateManyMutationInput {
  lastWeek?: Int;
}

export interface ReviewUpdateWithoutPlaceDataInput {
  text?: String;
  stars?: Int;
  accuracy?: Int;
  location?: Int;
  checkIn?: Int;
  value?: Int;
  cleanliness?: Int;
  communication?: Int;
  experience?: ExperienceUpdateOneWithoutReviewsInput;
}

export type CityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExperienceUpdateOneWithoutReviewsInput {
  create?: ExperienceCreateWithoutReviewsInput;
  update?: ExperienceUpdateWithoutReviewsDataInput;
  upsert?: ExperienceUpsertWithoutReviewsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExperienceWhereUniqueInput;
}

export interface PlaceUpdateWithoutViewsDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneRequiredWithoutPlaceInput;
  host?: UserUpdateOneRequiredWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneRequiredWithoutPlaceInput;
  location?: LocationUpdateOneRequiredWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface ExperienceUpdateWithoutReviewsDataInput {
  category?: ExperienceCategoryUpdateOneWithoutExperienceInput;
  title?: String;
  host?: UserUpdateOneRequiredWithoutHostingExperiencesInput;
  location?: LocationUpdateOneRequiredWithoutExperienceInput;
  pricePerPerson?: Int;
  preview?: PictureUpdateOneRequiredInput;
  popularity?: Int;
}

export interface ViewsUpdateInput {
  lastWeek?: Int;
  place?: PlaceUpdateOneRequiredWithoutViewsInput;
}

export interface ExperienceCategoryUpdateOneWithoutExperienceInput {
  create?: ExperienceCategoryCreateWithoutExperienceInput;
  update?: ExperienceCategoryUpdateWithoutExperienceDataInput;
  upsert?: ExperienceCategoryUpsertWithoutExperienceInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExperienceCategoryWhereUniqueInput;
}

export interface PlaceCreateWithoutViewsInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface ExperienceCategoryUpdateWithoutExperienceDataInput {
  mainColor?: String;
  name?: String;
}

export interface ViewsCreateInput {
  lastWeek: Int;
  place: PlaceCreateOneWithoutViewsInput;
}

export interface ExperienceCategoryUpsertWithoutExperienceInput {
  update: ExperienceCategoryUpdateWithoutExperienceDataInput;
  create: ExperienceCategoryCreateWithoutExperienceInput;
}

export type ExperienceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateOneRequiredWithoutHostingExperiencesInput {
  create?: UserCreateWithoutHostingExperiencesInput;
  update?: UserUpdateWithoutHostingExperiencesDataInput;
  upsert?: UserUpsertWithoutHostingExperiencesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface UserUpdateWithoutHostingExperiencesDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
}

export type ExperienceCategoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PlaceUpdateManyWithoutHostInput {
  create?: PlaceCreateWithoutHostInput[] | PlaceCreateWithoutHostInput;
  delete?: PlaceWhereUniqueInput[] | PlaceWhereUniqueInput;
  connect?: PlaceWhereUniqueInput[] | PlaceWhereUniqueInput;
  disconnect?: PlaceWhereUniqueInput[] | PlaceWhereUniqueInput;
  update?:
    | PlaceUpdateWithWhereUniqueWithoutHostInput[]
    | PlaceUpdateWithWhereUniqueWithoutHostInput;
  upsert?:
    | PlaceUpsertWithWhereUniqueWithoutHostInput[]
    | PlaceUpsertWithWhereUniqueWithoutHostInput;
}

export interface ReviewUpdateInput {
  text?: String;
  stars?: Int;
  accuracy?: Int;
  location?: Int;
  checkIn?: Int;
  value?: Int;
  cleanliness?: Int;
  communication?: Int;
  place?: PlaceUpdateOneRequiredWithoutReviewsInput;
  experience?: ExperienceUpdateOneWithoutReviewsInput;
}

export interface PlaceUpdateWithWhereUniqueWithoutHostInput {
  where: PlaceWhereUniqueInput;
  data: PlaceUpdateWithoutHostDataInput;
}

export interface RestaurantUpdateManyMutationInput {
  title?: String;
  avgPricePerPerson?: Int;
  isCurated?: Boolean;
  slug?: String;
  popularity?: Int;
}

export interface PlaceUpdateWithoutHostDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneRequiredWithoutPlaceInput;
  pricing?: PricingUpdateOneRequiredWithoutPlaceInput;
  location?: LocationUpdateOneRequiredWithoutPlaceInput;
  views?: ViewsUpdateOneRequiredWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface LocationUpsertWithoutRestaurantInput {
  update: LocationUpdateWithoutRestaurantDataInput;
  create: LocationCreateWithoutRestaurantInput;
}

export interface AmenitiesUpdateOneRequiredWithoutPlaceInput {
  create?: AmenitiesCreateWithoutPlaceInput;
  update?: AmenitiesUpdateWithoutPlaceDataInput;
  upsert?: AmenitiesUpsertWithoutPlaceInput;
  connect?: AmenitiesWhereUniqueInput;
}

export interface LocationUpdateOneRequiredWithoutRestaurantInput {
  create?: LocationCreateWithoutRestaurantInput;
  update?: LocationUpdateWithoutRestaurantDataInput;
  upsert?: LocationUpsertWithoutRestaurantInput;
  connect?: LocationWhereUniqueInput;
}

export interface AmenitiesUpdateWithoutPlaceDataInput {
  elevator?: Boolean;
  petsAllowed?: Boolean;
  internet?: Boolean;
  kitchen?: Boolean;
  wirelessInternet?: Boolean;
  familyKidFriendly?: Boolean;
  freeParkingOnPremises?: Boolean;
  hotTub?: Boolean;
  pool?: Boolean;
  smokingAllowed?: Boolean;
  wheelchairAccessible?: Boolean;
  breakfast?: Boolean;
  cableTv?: Boolean;
  suitableForEvents?: Boolean;
  dryer?: Boolean;
  washer?: Boolean;
  indoorFireplace?: Boolean;
  tv?: Boolean;
  heating?: Boolean;
  hangers?: Boolean;
  iron?: Boolean;
  hairDryer?: Boolean;
  doorman?: Boolean;
  paidParkingOffPremises?: Boolean;
  freeParkingOnStreet?: Boolean;
  gym?: Boolean;
  airConditioning?: Boolean;
  shampoo?: Boolean;
  essentials?: Boolean;
  laptopFriendlyWorkspace?: Boolean;
  privateEntrance?: Boolean;
  buzzerWirelessIntercom?: Boolean;
  babyBath?: Boolean;
  babyMonitor?: Boolean;
  babysitterRecommendations?: Boolean;
  bathtub?: Boolean;
  changingTable?: Boolean;
  childrensBooksAndToys?: Boolean;
  childrensDinnerware?: Boolean;
  crib?: Boolean;
}

export type HouseRulesWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AmenitiesUpsertWithoutPlaceInput {
  update: AmenitiesUpdateWithoutPlaceDataInput;
  create: AmenitiesCreateWithoutPlaceInput;
}

export interface LocationCreateWithoutRestaurantInput {
  lat: Float;
  lng: Float;
  neighbourHood?: NeighbourhoodCreateOneWithoutLocationsInput;
  user?: UserCreateOneWithoutLocationInput;
  place?: PlaceCreateOneWithoutLocationInput;
  address: String;
  directions: String;
  experience?: ExperienceCreateOneWithoutLocationInput;
}

export interface PricingUpdateOneRequiredWithoutPlaceInput {
  create?: PricingCreateWithoutPlaceInput;
  update?: PricingUpdateWithoutPlaceDataInput;
  upsert?: PricingUpsertWithoutPlaceInput;
  connect?: PricingWhereUniqueInput;
}

export interface RestaurantCreateInput {
  title: String;
  avgPricePerPerson: Int;
  pictures?: PictureCreateManyInput;
  location: LocationCreateOneWithoutRestaurantInput;
  isCurated?: Boolean;
  slug: String;
  popularity: Int;
}

export interface PricingUpdateWithoutPlaceDataInput {
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight?: Int;
  smartPricing?: Boolean;
  basePrice?: Int;
  averageWeekly?: Int;
  averageMonthly?: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export interface PricingUpdateManyMutationInput {
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight?: Int;
  smartPricing?: Boolean;
  basePrice?: Int;
  averageWeekly?: Int;
  averageMonthly?: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export interface PricingUpsertWithoutPlaceInput {
  update: PricingUpdateWithoutPlaceDataInput;
  create: PricingCreateWithoutPlaceInput;
}

export interface PlaceUpdateWithoutPricingDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneRequiredWithoutPlaceInput;
  host?: UserUpdateOneRequiredWithoutOwnedPlacesInput;
  location?: LocationUpdateOneRequiredWithoutPlaceInput;
  views?: ViewsUpdateOneRequiredWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface LocationUpdateOneRequiredWithoutPlaceInput {
  create?: LocationCreateWithoutPlaceInput;
  update?: LocationUpdateWithoutPlaceDataInput;
  upsert?: LocationUpsertWithoutPlaceInput;
  connect?: LocationWhereUniqueInput;
}

export interface PlaceUpdateOneRequiredWithoutPricingInput {
  create?: PlaceCreateWithoutPricingInput;
  update?: PlaceUpdateWithoutPricingDataInput;
  upsert?: PlaceUpsertWithoutPricingInput;
  connect?: PlaceWhereUniqueInput;
}

export interface LocationUpdateWithoutPlaceDataInput {
  lat?: Float;
  lng?: Float;
  neighbourHood?: NeighbourhoodUpdateOneWithoutLocationsInput;
  user?: UserUpdateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceUpdateOneWithoutLocationInput;
  restaurant?: RestaurantUpdateOneWithoutLocationInput;
}

export interface PlaceCreateWithoutPricingInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface NeighbourhoodUpdateOneWithoutLocationsInput {
  create?: NeighbourhoodCreateWithoutLocationsInput;
  update?: NeighbourhoodUpdateWithoutLocationsDataInput;
  upsert?: NeighbourhoodUpsertWithoutLocationsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: NeighbourhoodWhereUniqueInput;
}

export interface PlaceCreateOneWithoutPricingInput {
  create?: PlaceCreateWithoutPricingInput;
  connect?: PlaceWhereUniqueInput;
}

export interface NeighbourhoodUpdateWithoutLocationsDataInput {
  name?: String;
  slug?: String;
  homePreview?: PictureUpdateOneInput;
  city?: CityUpdateOneRequiredWithoutNeighbourhoodsInput;
  featured?: Boolean;
  popularity?: Int;
}

export interface PoliciesUpdateManyMutationInput {
  checkInStartTime?: Float;
  checkInEndTime?: Float;
  checkoutTime?: Float;
}

export interface PictureUpdateOneInput {
  create?: PictureCreateInput;
  update?: PictureUpdateDataInput;
  upsert?: PictureUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PictureWhereUniqueInput;
}

export interface PlaceUpsertWithoutPoliciesInput {
  update: PlaceUpdateWithoutPoliciesDataInput;
  create: PlaceCreateWithoutPoliciesInput;
}

export interface PictureUpdateDataInput {
  url?: String;
}

export interface PlaceUpdateOneRequiredWithoutPoliciesInput {
  create?: PlaceCreateWithoutPoliciesInput;
  update?: PlaceUpdateWithoutPoliciesDataInput;
  upsert?: PlaceUpsertWithoutPoliciesInput;
  connect?: PlaceWhereUniqueInput;
}

export interface PictureUpsertNestedInput {
  update: PictureUpdateDataInput;
  create: PictureCreateInput;
}

export interface PoliciesUpdateInput {
  checkInStartTime?: Float;
  checkInEndTime?: Float;
  checkoutTime?: Float;
  place?: PlaceUpdateOneRequiredWithoutPoliciesInput;
}

export interface CityUpdateOneRequiredWithoutNeighbourhoodsInput {
  create?: CityCreateWithoutNeighbourhoodsInput;
  update?: CityUpdateWithoutNeighbourhoodsDataInput;
  upsert?: CityUpsertWithoutNeighbourhoodsInput;
  connect?: CityWhereUniqueInput;
}

export interface PlaceCreateOneWithoutPoliciesInput {
  create?: PlaceCreateWithoutPoliciesInput;
  connect?: PlaceWhereUniqueInput;
}

export interface CityUpdateWithoutNeighbourhoodsDataInput {
  name?: String;
}

export interface PoliciesCreateInput {
  checkInStartTime: Float;
  checkInEndTime: Float;
  checkoutTime: Float;
  place: PlaceCreateOneWithoutPoliciesInput;
}

export interface CityUpsertWithoutNeighbourhoodsInput {
  update: CityUpdateWithoutNeighbourhoodsDataInput;
  create: CityCreateWithoutNeighbourhoodsInput;
}

export interface PlaceUpdateInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneRequiredWithoutPlaceInput;
  host?: UserUpdateOneRequiredWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneRequiredWithoutPlaceInput;
  location?: LocationUpdateOneRequiredWithoutPlaceInput;
  views?: ViewsUpdateOneRequiredWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface NeighbourhoodUpsertWithoutLocationsInput {
  update: NeighbourhoodUpdateWithoutLocationsDataInput;
  create: NeighbourhoodCreateWithoutLocationsInput;
}

export interface PlaceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  size?: PLACE_SIZES;
  size_not?: PLACE_SIZES;
  size_in?: PLACE_SIZES[] | PLACE_SIZES;
  size_not_in?: PLACE_SIZES[] | PLACE_SIZES;
  shortDescription?: String;
  shortDescription_not?: String;
  shortDescription_in?: String[] | String;
  shortDescription_not_in?: String[] | String;
  shortDescription_lt?: String;
  shortDescription_lte?: String;
  shortDescription_gt?: String;
  shortDescription_gte?: String;
  shortDescription_contains?: String;
  shortDescription_not_contains?: String;
  shortDescription_starts_with?: String;
  shortDescription_not_starts_with?: String;
  shortDescription_ends_with?: String;
  shortDescription_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  maxGuests?: Int;
  maxGuests_not?: Int;
  maxGuests_in?: Int[] | Int;
  maxGuests_not_in?: Int[] | Int;
  maxGuests_lt?: Int;
  maxGuests_lte?: Int;
  maxGuests_gt?: Int;
  maxGuests_gte?: Int;
  numBedrooms?: Int;
  numBedrooms_not?: Int;
  numBedrooms_in?: Int[] | Int;
  numBedrooms_not_in?: Int[] | Int;
  numBedrooms_lt?: Int;
  numBedrooms_lte?: Int;
  numBedrooms_gt?: Int;
  numBedrooms_gte?: Int;
  numBeds?: Int;
  numBeds_not?: Int;
  numBeds_in?: Int[] | Int;
  numBeds_not_in?: Int[] | Int;
  numBeds_lt?: Int;
  numBeds_lte?: Int;
  numBeds_gt?: Int;
  numBeds_gte?: Int;
  numBaths?: Int;
  numBaths_not?: Int;
  numBaths_in?: Int[] | Int;
  numBaths_not_in?: Int[] | Int;
  numBaths_lt?: Int;
  numBaths_lte?: Int;
  numBaths_gt?: Int;
  numBaths_gte?: Int;
  reviews_every?: ReviewWhereInput;
  reviews_some?: ReviewWhereInput;
  reviews_none?: ReviewWhereInput;
  amenities?: AmenitiesWhereInput;
  host?: UserWhereInput;
  pricing?: PricingWhereInput;
  location?: LocationWhereInput;
  views?: ViewsWhereInput;
  guestRequirements?: GuestRequirementsWhereInput;
  policies?: PoliciesWhereInput;
  houseRules?: HouseRulesWhereInput;
  bookings_every?: BookingWhereInput;
  bookings_some?: BookingWhereInput;
  bookings_none?: BookingWhereInput;
  pictures_every?: PictureWhereInput;
  pictures_some?: PictureWhereInput;
  pictures_none?: PictureWhereInput;
  popularity?: Int;
  popularity_not?: Int;
  popularity_in?: Int[] | Int;
  popularity_not_in?: Int[] | Int;
  popularity_lt?: Int;
  popularity_lte?: Int;
  popularity_gt?: Int;
  popularity_gte?: Int;
  AND?: PlaceWhereInput[] | PlaceWhereInput;
  OR?: PlaceWhereInput[] | PlaceWhereInput;
  NOT?: PlaceWhereInput[] | PlaceWhereInput;
}

export interface UserUpdateOneWithoutLocationInput {
  create?: UserCreateWithoutLocationInput;
  update?: UserUpdateWithoutLocationDataInput;
  upsert?: UserUpsertWithoutLocationInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface PictureUpdateManyMutationInput {
  url?: String;
}

export interface UserUpdateWithoutLocationDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export type PictureWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BookingUpdateManyWithoutBookeeInput {
  create?: BookingCreateWithoutBookeeInput[] | BookingCreateWithoutBookeeInput;
  delete?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  disconnect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  update?:
    | BookingUpdateWithWhereUniqueWithoutBookeeInput[]
    | BookingUpdateWithWhereUniqueWithoutBookeeInput;
  upsert?:
    | BookingUpsertWithWhereUniqueWithoutBookeeInput[]
    | BookingUpsertWithWhereUniqueWithoutBookeeInput;
}

export interface PaymentAccountUpsertWithoutPaypalInput {
  update: PaymentAccountUpdateWithoutPaypalDataInput;
  create: PaymentAccountCreateWithoutPaypalInput;
}

export interface BookingUpdateWithWhereUniqueWithoutBookeeInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutBookeeDataInput;
}

export type PlaceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BookingUpdateWithoutBookeeDataInput {
  place?: PlaceUpdateOneRequiredWithoutBookingsInput;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  payment?: PaymentUpdateOneWithoutBookingInput;
}

export interface PaypalInformationUpdateInput {
  email?: String;
  paymentAccount?: PaymentAccountUpdateOneRequiredWithoutPaypalInput;
}

export interface PlaceUpdateOneRequiredWithoutBookingsInput {
  create?: PlaceCreateWithoutBookingsInput;
  update?: PlaceUpdateWithoutBookingsDataInput;
  upsert?: PlaceUpsertWithoutBookingsInput;
  connect?: PlaceWhereUniqueInput;
}

export type PoliciesWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface LocationUpdateManyMutationInput {
  lat?: Float;
  lng?: Float;
  address?: String;
  directions?: String;
}

export interface PaypalInformationCreateInput {
  email: String;
  paymentAccount: PaymentAccountCreateOneWithoutPaypalInput;
}

export interface UserUpdateOneRequiredWithoutOwnedPlacesInput {
  create?: UserCreateWithoutOwnedPlacesInput;
  update?: UserUpdateWithoutOwnedPlacesDataInput;
  upsert?: UserUpsertWithoutOwnedPlacesInput;
  connect?: UserWhereUniqueInput;
}

export interface PaymentAccountUpdateInput {
  type?: PAYMENT_PROVIDER;
  user?: UserUpdateOneRequiredWithoutPaymentAccountInput;
  payments?: PaymentUpdateManyWithoutPaymentMethodInput;
  paypal?: PaypalInformationUpdateOneWithoutPaymentAccountInput;
  creditcard?: CreditCardInformationUpdateOneWithoutPaymentAccountInput;
}

export interface UserUpdateWithoutOwnedPlacesDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface ReviewWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  stars?: Int;
  stars_not?: Int;
  stars_in?: Int[] | Int;
  stars_not_in?: Int[] | Int;
  stars_lt?: Int;
  stars_lte?: Int;
  stars_gt?: Int;
  stars_gte?: Int;
  accuracy?: Int;
  accuracy_not?: Int;
  accuracy_in?: Int[] | Int;
  accuracy_not_in?: Int[] | Int;
  accuracy_lt?: Int;
  accuracy_lte?: Int;
  accuracy_gt?: Int;
  accuracy_gte?: Int;
  location?: Int;
  location_not?: Int;
  location_in?: Int[] | Int;
  location_not_in?: Int[] | Int;
  location_lt?: Int;
  location_lte?: Int;
  location_gt?: Int;
  location_gte?: Int;
  checkIn?: Int;
  checkIn_not?: Int;
  checkIn_in?: Int[] | Int;
  checkIn_not_in?: Int[] | Int;
  checkIn_lt?: Int;
  checkIn_lte?: Int;
  checkIn_gt?: Int;
  checkIn_gte?: Int;
  value?: Int;
  value_not?: Int;
  value_in?: Int[] | Int;
  value_not_in?: Int[] | Int;
  value_lt?: Int;
  value_lte?: Int;
  value_gt?: Int;
  value_gte?: Int;
  cleanliness?: Int;
  cleanliness_not?: Int;
  cleanliness_in?: Int[] | Int;
  cleanliness_not_in?: Int[] | Int;
  cleanliness_lt?: Int;
  cleanliness_lte?: Int;
  cleanliness_gt?: Int;
  cleanliness_gte?: Int;
  communication?: Int;
  communication_not?: Int;
  communication_in?: Int[] | Int;
  communication_not_in?: Int[] | Int;
  communication_lt?: Int;
  communication_lte?: Int;
  communication_gt?: Int;
  communication_gte?: Int;
  place?: PlaceWhereInput;
  experience?: ExperienceWhereInput;
  AND?: ReviewWhereInput[] | ReviewWhereInput;
  OR?: ReviewWhereInput[] | ReviewWhereInput;
  NOT?: ReviewWhereInput[] | ReviewWhereInput;
}

export interface LocationUpdateOneWithoutUserInput {
  create?: LocationCreateWithoutUserInput;
  update?: LocationUpdateWithoutUserDataInput;
  upsert?: LocationUpsertWithoutUserInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LocationWhereUniqueInput;
}

export interface PaymentUpdateManyMutationInput {
  serviceFee?: Float;
  placePrice?: Float;
  totalPrice?: Float;
}

export interface LocationUpdateWithoutUserDataInput {
  lat?: Float;
  lng?: Float;
  neighbourHood?: NeighbourhoodUpdateOneWithoutLocationsInput;
  place?: PlaceUpdateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceUpdateOneWithoutLocationInput;
  restaurant?: RestaurantUpdateOneWithoutLocationInput;
}

export type RestaurantWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PlaceUpdateOneWithoutLocationInput {
  create?: PlaceCreateWithoutLocationInput;
  update?: PlaceUpdateWithoutLocationDataInput;
  upsert?: PlaceUpsertWithoutLocationInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PlaceWhereUniqueInput;
}

export interface NotificationUpdateManyMutationInput {
  type?: NOTIFICATION_TYPE;
  link?: String;
  readDate?: DateTimeInput;
}

export interface PlaceUpdateWithoutLocationDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneRequiredWithoutPlaceInput;
  host?: UserUpdateOneRequiredWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneRequiredWithoutPlaceInput;
  views?: ViewsUpdateOneRequiredWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface UserUpdateWithoutNotificationsDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface ViewsUpdateOneRequiredWithoutPlaceInput {
  create?: ViewsCreateWithoutPlaceInput;
  update?: ViewsUpdateWithoutPlaceDataInput;
  upsert?: ViewsUpsertWithoutPlaceInput;
  connect?: ViewsWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutNotificationsInput {
  create?: UserCreateWithoutNotificationsInput;
  update?: UserUpdateWithoutNotificationsDataInput;
  upsert?: UserUpsertWithoutNotificationsInput;
  connect?: UserWhereUniqueInput;
}

export interface ViewsUpdateWithoutPlaceDataInput {
  lastWeek?: Int;
}

export interface UserCreateWithoutNotificationsInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface ViewsUpsertWithoutPlaceInput {
  update: ViewsUpdateWithoutPlaceDataInput;
  create: ViewsCreateWithoutPlaceInput;
}

export interface UserCreateOneWithoutNotificationsInput {
  create?: UserCreateWithoutNotificationsInput;
  connect?: UserWhereUniqueInput;
}

export interface GuestRequirementsUpdateOneWithoutPlaceInput {
  create?: GuestRequirementsCreateWithoutPlaceInput;
  update?: GuestRequirementsUpdateWithoutPlaceDataInput;
  upsert?: GuestRequirementsUpsertWithoutPlaceInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: GuestRequirementsWhereUniqueInput;
}

export interface NeighbourhoodUpdateManyMutationInput {
  name?: String;
  slug?: String;
  featured?: Boolean;
  popularity?: Int;
}

export interface GuestRequirementsUpdateWithoutPlaceDataInput {
  govIssuedId?: Boolean;
  recommendationsFromOtherHosts?: Boolean;
  guestTripInformation?: Boolean;
}

export type ViewsWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GuestRequirementsUpsertWithoutPlaceInput {
  update: GuestRequirementsUpdateWithoutPlaceDataInput;
  create: GuestRequirementsCreateWithoutPlaceInput;
}

export interface MessageUpdateManyMutationInput {
  deliveredAt?: DateTimeInput;
  readAt?: DateTimeInput;
}

export interface PoliciesUpdateOneWithoutPlaceInput {
  create?: PoliciesCreateWithoutPlaceInput;
  update?: PoliciesUpdateWithoutPlaceDataInput;
  upsert?: PoliciesUpsertWithoutPlaceInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PoliciesWhereUniqueInput;
}

export interface MessageCreateInput {
  from: UserCreateOneWithoutSentMessagesInput;
  to: UserCreateOneWithoutReceivedMessagesInput;
  deliveredAt: DateTimeInput;
  readAt: DateTimeInput;
}

export interface PoliciesUpdateWithoutPlaceDataInput {
  checkInStartTime?: Float;
  checkInEndTime?: Float;
  checkoutTime?: Float;
}

export interface AmenitiesCreateInput {
  place: PlaceCreateOneWithoutAmenitiesInput;
  elevator?: Boolean;
  petsAllowed?: Boolean;
  internet?: Boolean;
  kitchen?: Boolean;
  wirelessInternet?: Boolean;
  familyKidFriendly?: Boolean;
  freeParkingOnPremises?: Boolean;
  hotTub?: Boolean;
  pool?: Boolean;
  smokingAllowed?: Boolean;
  wheelchairAccessible?: Boolean;
  breakfast?: Boolean;
  cableTv?: Boolean;
  suitableForEvents?: Boolean;
  dryer?: Boolean;
  washer?: Boolean;
  indoorFireplace?: Boolean;
  tv?: Boolean;
  heating?: Boolean;
  hangers?: Boolean;
  iron?: Boolean;
  hairDryer?: Boolean;
  doorman?: Boolean;
  paidParkingOffPremises?: Boolean;
  freeParkingOnStreet?: Boolean;
  gym?: Boolean;
  airConditioning?: Boolean;
  shampoo?: Boolean;
  essentials?: Boolean;
  laptopFriendlyWorkspace?: Boolean;
  privateEntrance?: Boolean;
  buzzerWirelessIntercom?: Boolean;
  babyBath?: Boolean;
  babyMonitor?: Boolean;
  babysitterRecommendations?: Boolean;
  bathtub?: Boolean;
  changingTable?: Boolean;
  childrensBooksAndToys?: Boolean;
  childrensDinnerware?: Boolean;
  crib?: Boolean;
}

export interface NotificationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  type?: NOTIFICATION_TYPE;
  type_not?: NOTIFICATION_TYPE;
  type_in?: NOTIFICATION_TYPE[] | NOTIFICATION_TYPE;
  type_not_in?: NOTIFICATION_TYPE[] | NOTIFICATION_TYPE;
  user?: UserWhereInput;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  readDate?: DateTimeInput;
  readDate_not?: DateTimeInput;
  readDate_in?: DateTimeInput[] | DateTimeInput;
  readDate_not_in?: DateTimeInput[] | DateTimeInput;
  readDate_lt?: DateTimeInput;
  readDate_lte?: DateTimeInput;
  readDate_gt?: DateTimeInput;
  readDate_gte?: DateTimeInput;
  AND?: NotificationWhereInput[] | NotificationWhereInput;
  OR?: NotificationWhereInput[] | NotificationWhereInput;
  NOT?: NotificationWhereInput[] | NotificationWhereInput;
}

export interface PlaceCreateWithoutAmenitiesInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface GuestRequirementsWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  govIssuedId?: Boolean;
  govIssuedId_not?: Boolean;
  recommendationsFromOtherHosts?: Boolean;
  recommendationsFromOtherHosts_not?: Boolean;
  guestTripInformation?: Boolean;
  guestTripInformation_not?: Boolean;
  place?: PlaceWhereInput;
  AND?: GuestRequirementsWhereInput[] | GuestRequirementsWhereInput;
  OR?: GuestRequirementsWhereInput[] | GuestRequirementsWhereInput;
  NOT?: GuestRequirementsWhereInput[] | GuestRequirementsWhereInput;
}

export interface ReviewCreateWithoutPlaceInput {
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
  experience?: ExperienceCreateOneWithoutReviewsInput;
}

export interface HouseRulesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  suitableForChildren?: Boolean;
  suitableForChildren_not?: Boolean;
  suitableForInfants?: Boolean;
  suitableForInfants_not?: Boolean;
  petsAllowed?: Boolean;
  petsAllowed_not?: Boolean;
  smokingAllowed?: Boolean;
  smokingAllowed_not?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  partiesAndEventsAllowed_not?: Boolean;
  additionalRules?: String;
  additionalRules_not?: String;
  additionalRules_in?: String[] | String;
  additionalRules_not_in?: String[] | String;
  additionalRules_lt?: String;
  additionalRules_lte?: String;
  additionalRules_gt?: String;
  additionalRules_gte?: String;
  additionalRules_contains?: String;
  additionalRules_not_contains?: String;
  additionalRules_starts_with?: String;
  additionalRules_not_starts_with?: String;
  additionalRules_ends_with?: String;
  additionalRules_not_ends_with?: String;
  AND?: HouseRulesWhereInput[] | HouseRulesWhereInput;
  OR?: HouseRulesWhereInput[] | HouseRulesWhereInput;
  NOT?: HouseRulesWhereInput[] | HouseRulesWhereInput;
}

export interface ExperienceCreateWithoutReviewsInput {
  category?: ExperienceCategoryCreateOneWithoutExperienceInput;
  title: String;
  host: UserCreateOneWithoutHostingExperiencesInput;
  location: LocationCreateOneWithoutExperienceInput;
  pricePerPerson: Int;
  preview: PictureCreateOneInput;
  popularity: Int;
}

export interface LocationUpdateInput {
  lat?: Float;
  lng?: Float;
  neighbourHood?: NeighbourhoodUpdateOneWithoutLocationsInput;
  user?: UserUpdateOneWithoutLocationInput;
  place?: PlaceUpdateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceUpdateOneWithoutLocationInput;
  restaurant?: RestaurantUpdateOneWithoutLocationInput;
}

export interface ExperienceCategoryCreateWithoutExperienceInput {
  mainColor?: String;
  name: String;
}

export interface LocationCreateInput {
  lat: Float;
  lng: Float;
  neighbourHood?: NeighbourhoodCreateOneWithoutLocationsInput;
  user?: UserCreateOneWithoutLocationInput;
  place?: PlaceCreateOneWithoutLocationInput;
  address: String;
  directions: String;
  experience?: ExperienceCreateOneWithoutLocationInput;
  restaurant?: RestaurantCreateOneWithoutLocationInput;
}

export interface UserCreateWithoutHostingExperiencesInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
}

export interface BookingUpdateWithWhereUniqueWithoutPlaceInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutPlaceDataInput;
}

export interface PlaceCreateWithoutHostInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface BookingUpdateWithoutPlaceDataInput {
  bookee?: UserUpdateOneRequiredWithoutBookingsInput;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  payment?: PaymentUpdateOneWithoutBookingInput;
}

export interface AmenitiesCreateWithoutPlaceInput {
  elevator?: Boolean;
  petsAllowed?: Boolean;
  internet?: Boolean;
  kitchen?: Boolean;
  wirelessInternet?: Boolean;
  familyKidFriendly?: Boolean;
  freeParkingOnPremises?: Boolean;
  hotTub?: Boolean;
  pool?: Boolean;
  smokingAllowed?: Boolean;
  wheelchairAccessible?: Boolean;
  breakfast?: Boolean;
  cableTv?: Boolean;
  suitableForEvents?: Boolean;
  dryer?: Boolean;
  washer?: Boolean;
  indoorFireplace?: Boolean;
  tv?: Boolean;
  heating?: Boolean;
  hangers?: Boolean;
  iron?: Boolean;
  hairDryer?: Boolean;
  doorman?: Boolean;
  paidParkingOffPremises?: Boolean;
  freeParkingOnStreet?: Boolean;
  gym?: Boolean;
  airConditioning?: Boolean;
  shampoo?: Boolean;
  essentials?: Boolean;
  laptopFriendlyWorkspace?: Boolean;
  privateEntrance?: Boolean;
  buzzerWirelessIntercom?: Boolean;
  babyBath?: Boolean;
  babyMonitor?: Boolean;
  babysitterRecommendations?: Boolean;
  bathtub?: Boolean;
  changingTable?: Boolean;
  childrensBooksAndToys?: Boolean;
  childrensDinnerware?: Boolean;
  crib?: Boolean;
}

export interface UserUpdateOneRequiredWithoutBookingsInput {
  create?: UserCreateWithoutBookingsInput;
  update?: UserUpdateWithoutBookingsDataInput;
  upsert?: UserUpsertWithoutBookingsInput;
  connect?: UserWhereUniqueInput;
}

export interface PricingCreateWithoutPlaceInput {
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight: Int;
  smartPricing?: Boolean;
  basePrice: Int;
  averageWeekly: Int;
  averageMonthly: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export interface UserUpdateWithoutBookingsDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface LocationCreateWithoutPlaceInput {
  lat: Float;
  lng: Float;
  neighbourHood?: NeighbourhoodCreateOneWithoutLocationsInput;
  user?: UserCreateOneWithoutLocationInput;
  address: String;
  directions: String;
  experience?: ExperienceCreateOneWithoutLocationInput;
  restaurant?: RestaurantCreateOneWithoutLocationInput;
}

export interface PaymentAccountUpdateManyWithoutUserInput {
  create?:
    | PaymentAccountCreateWithoutUserInput[]
    | PaymentAccountCreateWithoutUserInput;
  delete?: PaymentAccountWhereUniqueInput[] | PaymentAccountWhereUniqueInput;
  connect?: PaymentAccountWhereUniqueInput[] | PaymentAccountWhereUniqueInput;
  disconnect?:
    | PaymentAccountWhereUniqueInput[]
    | PaymentAccountWhereUniqueInput;
  update?:
    | PaymentAccountUpdateWithWhereUniqueWithoutUserInput[]
    | PaymentAccountUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | PaymentAccountUpsertWithWhereUniqueWithoutUserInput[]
    | PaymentAccountUpsertWithWhereUniqueWithoutUserInput;
}

export interface NeighbourhoodCreateWithoutLocationsInput {
  name: String;
  slug: String;
  homePreview?: PictureCreateOneInput;
  city: CityCreateOneWithoutNeighbourhoodsInput;
  featured: Boolean;
  popularity: Int;
}

export interface PaymentAccountUpdateWithWhereUniqueWithoutUserInput {
  where: PaymentAccountWhereUniqueInput;
  data: PaymentAccountUpdateWithoutUserDataInput;
}

export interface PictureCreateInput {
  url: String;
}

export interface PaymentAccountUpdateWithoutUserDataInput {
  type?: PAYMENT_PROVIDER;
  payments?: PaymentUpdateManyWithoutPaymentMethodInput;
  paypal?: PaypalInformationUpdateOneWithoutPaymentAccountInput;
  creditcard?: CreditCardInformationUpdateOneWithoutPaymentAccountInput;
}

export interface CityCreateWithoutNeighbourhoodsInput {
  name: String;
}

export interface PaymentUpdateManyWithoutPaymentMethodInput {
  create?:
    | PaymentCreateWithoutPaymentMethodInput[]
    | PaymentCreateWithoutPaymentMethodInput;
  delete?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  connect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  disconnect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  update?:
    | PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    | PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput;
  upsert?:
    | PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    | PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput;
}

export interface UserCreateWithoutLocationInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput {
  where: PaymentWhereUniqueInput;
  data: PaymentUpdateWithoutPaymentMethodDataInput;
}

export interface BookingCreateWithoutBookeeInput {
  place: PlaceCreateOneWithoutBookingsInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
  payment?: PaymentCreateOneWithoutBookingInput;
}

export interface PaymentUpdateWithoutPaymentMethodDataInput {
  serviceFee?: Float;
  placePrice?: Float;
  totalPrice?: Float;
  booking?: BookingUpdateOneRequiredWithoutPaymentInput;
}

export interface PlaceCreateWithoutBookingsInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface BookingUpdateOneRequiredWithoutPaymentInput {
  create?: BookingCreateWithoutPaymentInput;
  update?: BookingUpdateWithoutPaymentDataInput;
  upsert?: BookingUpsertWithoutPaymentInput;
  connect?: BookingWhereUniqueInput;
}

export interface UserCreateWithoutOwnedPlacesInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface BookingUpdateWithoutPaymentDataInput {
  bookee?: UserUpdateOneRequiredWithoutBookingsInput;
  place?: PlaceUpdateOneRequiredWithoutBookingsInput;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
}

export interface LocationCreateWithoutUserInput {
  lat: Float;
  lng: Float;
  neighbourHood?: NeighbourhoodCreateOneWithoutLocationsInput;
  place?: PlaceCreateOneWithoutLocationInput;
  address: String;
  directions: String;
  experience?: ExperienceCreateOneWithoutLocationInput;
  restaurant?: RestaurantCreateOneWithoutLocationInput;
}

export interface BookingUpsertWithoutPaymentInput {
  update: BookingUpdateWithoutPaymentDataInput;
  create: BookingCreateWithoutPaymentInput;
}

export interface PlaceCreateWithoutLocationInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput {
  where: PaymentWhereUniqueInput;
  update: PaymentUpdateWithoutPaymentMethodDataInput;
  create: PaymentCreateWithoutPaymentMethodInput;
}

export interface ViewsCreateWithoutPlaceInput {
  lastWeek: Int;
}

export interface PaypalInformationUpdateOneWithoutPaymentAccountInput {
  create?: PaypalInformationCreateWithoutPaymentAccountInput;
  update?: PaypalInformationUpdateWithoutPaymentAccountDataInput;
  upsert?: PaypalInformationUpsertWithoutPaymentAccountInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PaypalInformationWhereUniqueInput;
}

export interface GuestRequirementsCreateWithoutPlaceInput {
  govIssuedId?: Boolean;
  recommendationsFromOtherHosts?: Boolean;
  guestTripInformation?: Boolean;
}

export interface PaypalInformationUpdateWithoutPaymentAccountDataInput {
  email?: String;
}

export interface PoliciesCreateWithoutPlaceInput {
  checkInStartTime: Float;
  checkInEndTime: Float;
  checkoutTime: Float;
}

export interface PaypalInformationUpsertWithoutPaymentAccountInput {
  update: PaypalInformationUpdateWithoutPaymentAccountDataInput;
  create: PaypalInformationCreateWithoutPaymentAccountInput;
}

export interface HouseRulesCreateInput {
  suitableForChildren?: Boolean;
  suitableForInfants?: Boolean;
  petsAllowed?: Boolean;
  smokingAllowed?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  additionalRules?: String;
}

export interface CreditCardInformationUpdateOneWithoutPaymentAccountInput {
  create?: CreditCardInformationCreateWithoutPaymentAccountInput;
  update?: CreditCardInformationUpdateWithoutPaymentAccountDataInput;
  upsert?: CreditCardInformationUpsertWithoutPaymentAccountInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CreditCardInformationWhereUniqueInput;
}

export interface BookingCreateWithoutPlaceInput {
  bookee: UserCreateOneWithoutBookingsInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
  payment?: PaymentCreateOneWithoutBookingInput;
}

export interface CreditCardInformationUpdateWithoutPaymentAccountDataInput {
  cardNumber?: String;
  expiresOnMonth?: Int;
  expiresOnYear?: Int;
  securityCode?: String;
  firstName?: String;
  lastName?: String;
  postalCode?: String;
  country?: String;
}

export interface UserCreateWithoutBookingsInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receivedMessages?: MessageCreateManyWithoutToInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface CreditCardInformationUpsertWithoutPaymentAccountInput {
  update: CreditCardInformationUpdateWithoutPaymentAccountDataInput;
  create: CreditCardInformationCreateWithoutPaymentAccountInput;
}

export interface PaymentAccountCreateWithoutUserInput {
  type?: PAYMENT_PROVIDER;
  payments?: PaymentCreateManyWithoutPaymentMethodInput;
  paypal?: PaypalInformationCreateOneWithoutPaymentAccountInput;
  creditcard?: CreditCardInformationCreateOneWithoutPaymentAccountInput;
}

export interface PaymentAccountUpsertWithWhereUniqueWithoutUserInput {
  where: PaymentAccountWhereUniqueInput;
  update: PaymentAccountUpdateWithoutUserDataInput;
  create: PaymentAccountCreateWithoutUserInput;
}

export interface PaymentCreateWithoutPaymentMethodInput {
  serviceFee: Float;
  placePrice: Float;
  totalPrice: Float;
  booking: BookingCreateOneWithoutPaymentInput;
}

export interface MessageUpdateManyWithoutFromInput {
  create?: MessageCreateWithoutFromInput[] | MessageCreateWithoutFromInput;
  delete?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  disconnect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  update?:
    | MessageUpdateWithWhereUniqueWithoutFromInput[]
    | MessageUpdateWithWhereUniqueWithoutFromInput;
  upsert?:
    | MessageUpsertWithWhereUniqueWithoutFromInput[]
    | MessageUpsertWithWhereUniqueWithoutFromInput;
}

export interface BookingCreateWithoutPaymentInput {
  bookee: UserCreateOneWithoutBookingsInput;
  place: PlaceCreateOneWithoutBookingsInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
}

export interface MessageUpdateWithWhereUniqueWithoutFromInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutFromDataInput;
}

export interface PaypalInformationCreateWithoutPaymentAccountInput {
  email: String;
}

export interface MessageUpdateWithoutFromDataInput {
  to?: UserUpdateOneRequiredWithoutReceivedMessagesInput;
  deliveredAt?: DateTimeInput;
  readAt?: DateTimeInput;
}

export interface CreditCardInformationCreateWithoutPaymentAccountInput {
  cardNumber: String;
  expiresOnMonth: Int;
  expiresOnYear: Int;
  securityCode: String;
  firstName: String;
  lastName: String;
  postalCode: String;
  country: String;
}

export interface UserUpdateOneRequiredWithoutReceivedMessagesInput {
  create?: UserCreateWithoutReceivedMessagesInput;
  update?: UserUpdateWithoutReceivedMessagesDataInput;
  upsert?: UserUpsertWithoutReceivedMessagesInput;
  connect?: UserWhereUniqueInput;
}

export interface MessageCreateWithoutFromInput {
  to: UserCreateOneWithoutReceivedMessagesInput;
  deliveredAt: DateTimeInput;
  readAt: DateTimeInput;
}

export interface UserUpdateWithoutReceivedMessagesDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface UserCreateWithoutReceivedMessagesInput {
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceCreateManyWithoutHostInput;
  location?: LocationCreateOneWithoutUserInput;
  bookings?: BookingCreateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountCreateManyWithoutUserInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  profilePicture?: PictureCreateOneInput;
  hostingExperiences?: ExperienceCreateManyWithoutHostInput;
}

export interface NotificationUpdateManyWithoutUserInput {
  create?:
    | NotificationCreateWithoutUserInput[]
    | NotificationCreateWithoutUserInput;
  delete?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  connect?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  disconnect?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  update?:
    | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    | NotificationUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    | NotificationUpsertWithWhereUniqueWithoutUserInput;
}

export interface NotificationCreateWithoutUserInput {
  type?: NOTIFICATION_TYPE;
  link: String;
  readDate: DateTimeInput;
}

export interface NotificationUpdateWithWhereUniqueWithoutUserInput {
  where: NotificationWhereUniqueInput;
  data: NotificationUpdateWithoutUserDataInput;
}

export interface ExperienceCreateWithoutHostInput {
  category?: ExperienceCategoryCreateOneWithoutExperienceInput;
  title: String;
  location: LocationCreateOneWithoutExperienceInput;
  pricePerPerson: Int;
  reviews?: ReviewCreateManyWithoutExperienceInput;
  preview: PictureCreateOneInput;
  popularity: Int;
}

export interface NotificationUpdateWithoutUserDataInput {
  type?: NOTIFICATION_TYPE;
  link?: String;
  readDate?: DateTimeInput;
}

export interface LocationCreateWithoutExperienceInput {
  lat: Float;
  lng: Float;
  neighbourHood?: NeighbourhoodCreateOneWithoutLocationsInput;
  user?: UserCreateOneWithoutLocationInput;
  place?: PlaceCreateOneWithoutLocationInput;
  address: String;
  directions: String;
  restaurant?: RestaurantCreateOneWithoutLocationInput;
}

export interface NotificationUpsertWithWhereUniqueWithoutUserInput {
  where: NotificationWhereUniqueInput;
  update: NotificationUpdateWithoutUserDataInput;
  create: NotificationCreateWithoutUserInput;
}

export interface RestaurantCreateWithoutLocationInput {
  title: String;
  avgPricePerPerson: Int;
  pictures?: PictureCreateManyInput;
  isCurated?: Boolean;
  slug: String;
  popularity: Int;
}

export interface ExperienceUpdateManyWithoutHostInput {
  create?:
    | ExperienceCreateWithoutHostInput[]
    | ExperienceCreateWithoutHostInput;
  delete?: ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput;
  connect?: ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput;
  disconnect?: ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput;
  update?:
    | ExperienceUpdateWithWhereUniqueWithoutHostInput[]
    | ExperienceUpdateWithWhereUniqueWithoutHostInput;
  upsert?:
    | ExperienceUpsertWithWhereUniqueWithoutHostInput[]
    | ExperienceUpsertWithWhereUniqueWithoutHostInput;
}

export interface ReviewCreateManyWithoutExperienceInput {
  create?:
    | ReviewCreateWithoutExperienceInput[]
    | ReviewCreateWithoutExperienceInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
}

export interface ExperienceUpdateWithWhereUniqueWithoutHostInput {
  where: ExperienceWhereUniqueInput;
  data: ExperienceUpdateWithoutHostDataInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface ExperienceUpdateWithoutHostDataInput {
  category?: ExperienceCategoryUpdateOneWithoutExperienceInput;
  title?: String;
  location?: LocationUpdateOneRequiredWithoutExperienceInput;
  pricePerPerson?: Int;
  reviews?: ReviewUpdateManyWithoutExperienceInput;
  preview?: PictureUpdateOneRequiredInput;
  popularity?: Int;
}

export interface PricingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PricingWhereInput;
  AND?: PricingSubscriptionWhereInput[] | PricingSubscriptionWhereInput;
  OR?: PricingSubscriptionWhereInput[] | PricingSubscriptionWhereInput;
  NOT?: PricingSubscriptionWhereInput[] | PricingSubscriptionWhereInput;
}

export interface LocationUpdateOneRequiredWithoutExperienceInput {
  create?: LocationCreateWithoutExperienceInput;
  update?: LocationUpdateWithoutExperienceDataInput;
  upsert?: LocationUpsertWithoutExperienceInput;
  connect?: LocationWhereUniqueInput;
}

export interface BookingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  bookee?: UserWhereInput;
  place?: PlaceWhereInput;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  endDate?: DateTimeInput;
  endDate_not?: DateTimeInput;
  endDate_in?: DateTimeInput[] | DateTimeInput;
  endDate_not_in?: DateTimeInput[] | DateTimeInput;
  endDate_lt?: DateTimeInput;
  endDate_lte?: DateTimeInput;
  endDate_gt?: DateTimeInput;
  endDate_gte?: DateTimeInput;
  payment?: PaymentWhereInput;
  AND?: BookingWhereInput[] | BookingWhereInput;
  OR?: BookingWhereInput[] | BookingWhereInput;
  NOT?: BookingWhereInput[] | BookingWhereInput;
}

export interface LocationUpdateWithoutExperienceDataInput {
  lat?: Float;
  lng?: Float;
  neighbourHood?: NeighbourhoodUpdateOneWithoutLocationsInput;
  user?: UserUpdateOneWithoutLocationInput;
  place?: PlaceUpdateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  restaurant?: RestaurantUpdateOneWithoutLocationInput;
}

export interface RestaurantWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  avgPricePerPerson?: Int;
  avgPricePerPerson_not?: Int;
  avgPricePerPerson_in?: Int[] | Int;
  avgPricePerPerson_not_in?: Int[] | Int;
  avgPricePerPerson_lt?: Int;
  avgPricePerPerson_lte?: Int;
  avgPricePerPerson_gt?: Int;
  avgPricePerPerson_gte?: Int;
  pictures_every?: PictureWhereInput;
  pictures_some?: PictureWhereInput;
  pictures_none?: PictureWhereInput;
  location?: LocationWhereInput;
  isCurated?: Boolean;
  isCurated_not?: Boolean;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  popularity?: Int;
  popularity_not?: Int;
  popularity_in?: Int[] | Int;
  popularity_not_in?: Int[] | Int;
  popularity_lt?: Int;
  popularity_lte?: Int;
  popularity_gt?: Int;
  popularity_gte?: Int;
  AND?: RestaurantWhereInput[] | RestaurantWhereInput;
  OR?: RestaurantWhereInput[] | RestaurantWhereInput;
  NOT?: RestaurantWhereInput[] | RestaurantWhereInput;
}

export interface RestaurantUpdateOneWithoutLocationInput {
  create?: RestaurantCreateWithoutLocationInput;
  update?: RestaurantUpdateWithoutLocationDataInput;
  upsert?: RestaurantUpsertWithoutLocationInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: RestaurantWhereUniqueInput;
}

export interface ExperienceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  category?: ExperienceCategoryWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  host?: UserWhereInput;
  location?: LocationWhereInput;
  pricePerPerson?: Int;
  pricePerPerson_not?: Int;
  pricePerPerson_in?: Int[] | Int;
  pricePerPerson_not_in?: Int[] | Int;
  pricePerPerson_lt?: Int;
  pricePerPerson_lte?: Int;
  pricePerPerson_gt?: Int;
  pricePerPerson_gte?: Int;
  reviews_every?: ReviewWhereInput;
  reviews_some?: ReviewWhereInput;
  reviews_none?: ReviewWhereInput;
  preview?: PictureWhereInput;
  popularity?: Int;
  popularity_not?: Int;
  popularity_in?: Int[] | Int;
  popularity_not_in?: Int[] | Int;
  popularity_lt?: Int;
  popularity_lte?: Int;
  popularity_gt?: Int;
  popularity_gte?: Int;
  AND?: ExperienceWhereInput[] | ExperienceWhereInput;
  OR?: ExperienceWhereInput[] | ExperienceWhereInput;
  NOT?: ExperienceWhereInput[] | ExperienceWhereInput;
}

export interface RestaurantUpdateWithoutLocationDataInput {
  title?: String;
  avgPricePerPerson?: Int;
  pictures?: PictureUpdateManyInput;
  isCurated?: Boolean;
  slug?: String;
  popularity?: Int;
}

export interface PictureWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: PictureWhereInput[] | PictureWhereInput;
  OR?: PictureWhereInput[] | PictureWhereInput;
  NOT?: PictureWhereInput[] | PictureWhereInput;
}

export interface PictureUpdateManyInput {
  create?: PictureCreateInput[] | PictureCreateInput;
  update?:
    | PictureUpdateWithWhereUniqueNestedInput[]
    | PictureUpdateWithWhereUniqueNestedInput;
  upsert?:
    | PictureUpsertWithWhereUniqueNestedInput[]
    | PictureUpsertWithWhereUniqueNestedInput;
  delete?: PictureWhereUniqueInput[] | PictureWhereUniqueInput;
  connect?: PictureWhereUniqueInput[] | PictureWhereUniqueInput;
  disconnect?: PictureWhereUniqueInput[] | PictureWhereUniqueInput;
}

export interface GuestRequirementsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GuestRequirementsWhereInput;
  AND?:
    | GuestRequirementsSubscriptionWhereInput[]
    | GuestRequirementsSubscriptionWhereInput;
  OR?:
    | GuestRequirementsSubscriptionWhereInput[]
    | GuestRequirementsSubscriptionWhereInput;
  NOT?:
    | GuestRequirementsSubscriptionWhereInput[]
    | GuestRequirementsSubscriptionWhereInput;
}

export interface PictureUpdateWithWhereUniqueNestedInput {
  where: PictureWhereUniqueInput;
  data: PictureUpdateDataInput;
}

export interface CreditCardInformationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CreditCardInformationWhereInput;
  AND?:
    | CreditCardInformationSubscriptionWhereInput[]
    | CreditCardInformationSubscriptionWhereInput;
  OR?:
    | CreditCardInformationSubscriptionWhereInput[]
    | CreditCardInformationSubscriptionWhereInput;
  NOT?:
    | CreditCardInformationSubscriptionWhereInput[]
    | CreditCardInformationSubscriptionWhereInput;
}

export interface PictureUpsertWithWhereUniqueNestedInput {
  where: PictureWhereUniqueInput;
  update: PictureUpdateDataInput;
  create: PictureCreateInput;
}

export interface AmenitiesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AmenitiesWhereInput;
  AND?: AmenitiesSubscriptionWhereInput[] | AmenitiesSubscriptionWhereInput;
  OR?: AmenitiesSubscriptionWhereInput[] | AmenitiesSubscriptionWhereInput;
  NOT?: AmenitiesSubscriptionWhereInput[] | AmenitiesSubscriptionWhereInput;
}

export interface RestaurantUpsertWithoutLocationInput {
  update: RestaurantUpdateWithoutLocationDataInput;
  create: RestaurantCreateWithoutLocationInput;
}

export interface LocationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  lat?: Float;
  lat_not?: Float;
  lat_in?: Float[] | Float;
  lat_not_in?: Float[] | Float;
  lat_lt?: Float;
  lat_lte?: Float;
  lat_gt?: Float;
  lat_gte?: Float;
  lng?: Float;
  lng_not?: Float;
  lng_in?: Float[] | Float;
  lng_not_in?: Float[] | Float;
  lng_lt?: Float;
  lng_lte?: Float;
  lng_gt?: Float;
  lng_gte?: Float;
  neighbourHood?: NeighbourhoodWhereInput;
  user?: UserWhereInput;
  place?: PlaceWhereInput;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  directions?: String;
  directions_not?: String;
  directions_in?: String[] | String;
  directions_not_in?: String[] | String;
  directions_lt?: String;
  directions_lte?: String;
  directions_gt?: String;
  directions_gte?: String;
  directions_contains?: String;
  directions_not_contains?: String;
  directions_starts_with?: String;
  directions_not_starts_with?: String;
  directions_ends_with?: String;
  directions_not_ends_with?: String;
  experience?: ExperienceWhereInput;
  restaurant?: RestaurantWhereInput;
  AND?: LocationWhereInput[] | LocationWhereInput;
  OR?: LocationWhereInput[] | LocationWhereInput;
  NOT?: LocationWhereInput[] | LocationWhereInput;
}

export interface LocationUpsertWithoutExperienceInput {
  update: LocationUpdateWithoutExperienceDataInput;
  create: LocationCreateWithoutExperienceInput;
}

export type CreditCardInformationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ReviewUpdateManyWithoutExperienceInput {
  create?:
    | ReviewCreateWithoutExperienceInput[]
    | ReviewCreateWithoutExperienceInput;
  delete?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  disconnect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
  update?:
    | ReviewUpdateWithWhereUniqueWithoutExperienceInput[]
    | ReviewUpdateWithWhereUniqueWithoutExperienceInput;
  upsert?:
    | ReviewUpsertWithWhereUniqueWithoutExperienceInput[]
    | ReviewUpsertWithWhereUniqueWithoutExperienceInput;
}

export interface UserUpdateManyMutationInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
}

export interface ReviewUpdateWithWhereUniqueWithoutExperienceInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutExperienceDataInput;
}

export interface ReviewUpdateManyMutationInput {
  text?: String;
  stars?: Int;
  accuracy?: Int;
  location?: Int;
  checkIn?: Int;
  value?: Int;
  cleanliness?: Int;
  communication?: Int;
}

export interface ReviewUpdateWithoutExperienceDataInput {
  text?: String;
  stars?: Int;
  accuracy?: Int;
  location?: Int;
  checkIn?: Int;
  value?: Int;
  cleanliness?: Int;
  communication?: Int;
  place?: PlaceUpdateOneRequiredWithoutReviewsInput;
}

export interface ReviewCreateInput {
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
  place: PlaceCreateOneWithoutReviewsInput;
  experience?: ExperienceCreateOneWithoutReviewsInput;
}

export interface PlaceUpdateOneRequiredWithoutReviewsInput {
  create?: PlaceCreateWithoutReviewsInput;
  update?: PlaceUpdateWithoutReviewsDataInput;
  upsert?: PlaceUpsertWithoutReviewsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface LocationUpdateWithoutRestaurantDataInput {
  lat?: Float;
  lng?: Float;
  neighbourHood?: NeighbourhoodUpdateOneWithoutLocationsInput;
  user?: UserUpdateOneWithoutLocationInput;
  place?: PlaceUpdateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceUpdateOneWithoutLocationInput;
}

export interface PlaceUpdateWithoutReviewsDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  amenities?: AmenitiesUpdateOneRequiredWithoutPlaceInput;
  host?: UserUpdateOneRequiredWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneRequiredWithoutPlaceInput;
  location?: LocationUpdateOneRequiredWithoutPlaceInput;
  views?: ViewsUpdateOneRequiredWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface AmenitiesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  place?: PlaceWhereInput;
  elevator?: Boolean;
  elevator_not?: Boolean;
  petsAllowed?: Boolean;
  petsAllowed_not?: Boolean;
  internet?: Boolean;
  internet_not?: Boolean;
  kitchen?: Boolean;
  kitchen_not?: Boolean;
  wirelessInternet?: Boolean;
  wirelessInternet_not?: Boolean;
  familyKidFriendly?: Boolean;
  familyKidFriendly_not?: Boolean;
  freeParkingOnPremises?: Boolean;
  freeParkingOnPremises_not?: Boolean;
  hotTub?: Boolean;
  hotTub_not?: Boolean;
  pool?: Boolean;
  pool_not?: Boolean;
  smokingAllowed?: Boolean;
  smokingAllowed_not?: Boolean;
  wheelchairAccessible?: Boolean;
  wheelchairAccessible_not?: Boolean;
  breakfast?: Boolean;
  breakfast_not?: Boolean;
  cableTv?: Boolean;
  cableTv_not?: Boolean;
  suitableForEvents?: Boolean;
  suitableForEvents_not?: Boolean;
  dryer?: Boolean;
  dryer_not?: Boolean;
  washer?: Boolean;
  washer_not?: Boolean;
  indoorFireplace?: Boolean;
  indoorFireplace_not?: Boolean;
  tv?: Boolean;
  tv_not?: Boolean;
  heating?: Boolean;
  heating_not?: Boolean;
  hangers?: Boolean;
  hangers_not?: Boolean;
  iron?: Boolean;
  iron_not?: Boolean;
  hairDryer?: Boolean;
  hairDryer_not?: Boolean;
  doorman?: Boolean;
  doorman_not?: Boolean;
  paidParkingOffPremises?: Boolean;
  paidParkingOffPremises_not?: Boolean;
  freeParkingOnStreet?: Boolean;
  freeParkingOnStreet_not?: Boolean;
  gym?: Boolean;
  gym_not?: Boolean;
  airConditioning?: Boolean;
  airConditioning_not?: Boolean;
  shampoo?: Boolean;
  shampoo_not?: Boolean;
  essentials?: Boolean;
  essentials_not?: Boolean;
  laptopFriendlyWorkspace?: Boolean;
  laptopFriendlyWorkspace_not?: Boolean;
  privateEntrance?: Boolean;
  privateEntrance_not?: Boolean;
  buzzerWirelessIntercom?: Boolean;
  buzzerWirelessIntercom_not?: Boolean;
  babyBath?: Boolean;
  babyBath_not?: Boolean;
  babyMonitor?: Boolean;
  babyMonitor_not?: Boolean;
  babysitterRecommendations?: Boolean;
  babysitterRecommendations_not?: Boolean;
  bathtub?: Boolean;
  bathtub_not?: Boolean;
  changingTable?: Boolean;
  changingTable_not?: Boolean;
  childrensBooksAndToys?: Boolean;
  childrensBooksAndToys_not?: Boolean;
  childrensDinnerware?: Boolean;
  childrensDinnerware_not?: Boolean;
  crib?: Boolean;
  crib_not?: Boolean;
  AND?: AmenitiesWhereInput[] | AmenitiesWhereInput;
  OR?: AmenitiesWhereInput[] | AmenitiesWhereInput;
  NOT?: AmenitiesWhereInput[] | AmenitiesWhereInput;
}

export interface PlaceUpsertWithoutReviewsInput {
  update: PlaceUpdateWithoutReviewsDataInput;
  create: PlaceCreateWithoutReviewsInput;
}

export type LocationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ReviewUpsertWithWhereUniqueWithoutExperienceInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutExperienceDataInput;
  create: ReviewCreateWithoutExperienceInput;
}

export type MessageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PictureUpdateOneRequiredInput {
  create?: PictureCreateInput;
  update?: PictureUpdateDataInput;
  upsert?: PictureUpsertNestedInput;
  connect?: PictureWhereUniqueInput;
}

export type NeighbourhoodWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExperienceUpsertWithWhereUniqueWithoutHostInput {
  where: ExperienceWhereUniqueInput;
  update: ExperienceUpdateWithoutHostDataInput;
  create: ExperienceCreateWithoutHostInput;
}

export type NotificationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpsertWithoutReceivedMessagesInput {
  update: UserUpdateWithoutReceivedMessagesDataInput;
  create: UserCreateWithoutReceivedMessagesInput;
}

export type PaymentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MessageUpsertWithWhereUniqueWithoutFromInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutFromDataInput;
  create: MessageCreateWithoutFromInput;
}

export type PaymentAccountWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MessageUpdateManyWithoutToInput {
  create?: MessageCreateWithoutToInput[] | MessageCreateWithoutToInput;
  delete?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  disconnect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  update?:
    | MessageUpdateWithWhereUniqueWithoutToInput[]
    | MessageUpdateWithWhereUniqueWithoutToInput;
  upsert?:
    | MessageUpsertWithWhereUniqueWithoutToInput[]
    | MessageUpsertWithWhereUniqueWithoutToInput;
}

export type PaypalInformationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MessageUpdateWithWhereUniqueWithoutToInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutToDataInput;
}

export interface PictureUpdateInput {
  url?: String;
}

export interface MessageUpdateWithoutToDataInput {
  from?: UserUpdateOneRequiredWithoutSentMessagesInput;
  deliveredAt?: DateTimeInput;
  readAt?: DateTimeInput;
}

export interface PaymentAccountUpdateWithoutPaypalDataInput {
  type?: PAYMENT_PROVIDER;
  user?: UserUpdateOneRequiredWithoutPaymentAccountInput;
  payments?: PaymentUpdateManyWithoutPaymentMethodInput;
  creditcard?: CreditCardInformationUpdateOneWithoutPaymentAccountInput;
}

export interface UserUpdateOneRequiredWithoutSentMessagesInput {
  create?: UserCreateWithoutSentMessagesInput;
  update?: UserUpdateWithoutSentMessagesDataInput;
  upsert?: UserUpsertWithoutSentMessagesInput;
  connect?: UserWhereUniqueInput;
}

export interface PaymentAccountCreateWithoutPaypalInput {
  type?: PAYMENT_PROVIDER;
  user: UserCreateOneWithoutPaymentAccountInput;
  payments?: PaymentCreateManyWithoutPaymentMethodInput;
  creditcard?: CreditCardInformationCreateOneWithoutPaymentAccountInput;
}

export interface UserUpdateWithoutSentMessagesDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface PaymentAccountUpdateManyMutationInput {
  type?: PAYMENT_PROVIDER;
}

export interface UserUpsertWithoutSentMessagesInput {
  update: UserUpdateWithoutSentMessagesDataInput;
  create: UserCreateWithoutSentMessagesInput;
}

export interface PaymentAccountCreateInput {
  type?: PAYMENT_PROVIDER;
  user: UserCreateOneWithoutPaymentAccountInput;
  payments?: PaymentCreateManyWithoutPaymentMethodInput;
  paypal?: PaypalInformationCreateOneWithoutPaymentAccountInput;
  creditcard?: CreditCardInformationCreateOneWithoutPaymentAccountInput;
}

export interface MessageUpsertWithWhereUniqueWithoutToInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutToDataInput;
  create: MessageCreateWithoutToInput;
}

export interface PaymentCreateInput {
  serviceFee: Float;
  placePrice: Float;
  totalPrice: Float;
  booking: BookingCreateOneWithoutPaymentInput;
  paymentMethod: PaymentAccountCreateOneWithoutPaymentsInput;
}

export interface UserUpsertWithoutBookingsInput {
  update: UserUpdateWithoutBookingsDataInput;
  create: UserCreateWithoutBookingsInput;
}

export type ReviewWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PaymentUpdateOneWithoutBookingInput {
  create?: PaymentCreateWithoutBookingInput;
  update?: PaymentUpdateWithoutBookingDataInput;
  upsert?: PaymentUpsertWithoutBookingInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PaymentWhereUniqueInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface PaymentUpdateWithoutBookingDataInput {
  serviceFee?: Float;
  placePrice?: Float;
  totalPrice?: Float;
  paymentMethod?: PaymentAccountUpdateOneRequiredWithoutPaymentsInput;
}

export interface NeighbourhoodUpdateInput {
  locations?: LocationUpdateManyWithoutNeighbourHoodInput;
  name?: String;
  slug?: String;
  homePreview?: PictureUpdateOneInput;
  city?: CityUpdateOneRequiredWithoutNeighbourhoodsInput;
  featured?: Boolean;
  popularity?: Int;
}

export interface PaymentAccountUpdateOneRequiredWithoutPaymentsInput {
  create?: PaymentAccountCreateWithoutPaymentsInput;
  update?: PaymentAccountUpdateWithoutPaymentsDataInput;
  upsert?: PaymentAccountUpsertWithoutPaymentsInput;
  connect?: PaymentAccountWhereUniqueInput;
}

export interface MessageUpdateInput {
  from?: UserUpdateOneRequiredWithoutSentMessagesInput;
  to?: UserUpdateOneRequiredWithoutReceivedMessagesInput;
  deliveredAt?: DateTimeInput;
  readAt?: DateTimeInput;
}

export interface PaymentAccountUpdateWithoutPaymentsDataInput {
  type?: PAYMENT_PROVIDER;
  user?: UserUpdateOneRequiredWithoutPaymentAccountInput;
  paypal?: PaypalInformationUpdateOneWithoutPaymentAccountInput;
  creditcard?: CreditCardInformationUpdateOneWithoutPaymentAccountInput;
}

export interface PlaceCreateOneWithoutAmenitiesInput {
  create?: PlaceCreateWithoutAmenitiesInput;
  connect?: PlaceWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutPaymentAccountInput {
  create?: UserCreateWithoutPaymentAccountInput;
  update?: UserUpdateWithoutPaymentAccountDataInput;
  upsert?: UserUpsertWithoutPaymentAccountInput;
  connect?: UserWhereUniqueInput;
}

export interface ExperienceCreateOneWithoutReviewsInput {
  create?: ExperienceCreateWithoutReviewsInput;
  connect?: ExperienceWhereUniqueInput;
}

export interface UserUpdateWithoutPaymentAccountDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface UserCreateOneWithoutHostingExperiencesInput {
  create?: UserCreateWithoutHostingExperiencesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpsertWithoutPaymentAccountInput {
  update: UserUpdateWithoutPaymentAccountDataInput;
  create: UserCreateWithoutPaymentAccountInput;
}

export interface AmenitiesCreateOneWithoutPlaceInput {
  create?: AmenitiesCreateWithoutPlaceInput;
  connect?: AmenitiesWhereUniqueInput;
}

export interface PaymentAccountUpsertWithoutPaymentsInput {
  update: PaymentAccountUpdateWithoutPaymentsDataInput;
  create: PaymentAccountCreateWithoutPaymentsInput;
}

export interface LocationCreateOneWithoutPlaceInput {
  create?: LocationCreateWithoutPlaceInput;
  connect?: LocationWhereUniqueInput;
}

export interface PaymentUpsertWithoutBookingInput {
  update: PaymentUpdateWithoutBookingDataInput;
  create: PaymentCreateWithoutBookingInput;
}

export interface PictureCreateOneInput {
  create?: PictureCreateInput;
  connect?: PictureWhereUniqueInput;
}

export interface BookingUpsertWithWhereUniqueWithoutPlaceInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutPlaceDataInput;
  create: BookingCreateWithoutPlaceInput;
}

export interface UserCreateOneWithoutLocationInput {
  create?: UserCreateWithoutLocationInput;
  connect?: UserWhereUniqueInput;
}

export interface PlaceUpsertWithoutLocationInput {
  update: PlaceUpdateWithoutLocationDataInput;
  create: PlaceCreateWithoutLocationInput;
}

export interface PlaceCreateOneWithoutBookingsInput {
  create?: PlaceCreateWithoutBookingsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface ExperienceUpdateOneWithoutLocationInput {
  create?: ExperienceCreateWithoutLocationInput;
  update?: ExperienceUpdateWithoutLocationDataInput;
  upsert?: ExperienceUpsertWithoutLocationInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExperienceWhereUniqueInput;
}

export interface LocationCreateOneWithoutUserInput {
  create?: LocationCreateWithoutUserInput;
  connect?: LocationWhereUniqueInput;
}

export interface ExperienceUpdateWithoutLocationDataInput {
  category?: ExperienceCategoryUpdateOneWithoutExperienceInput;
  title?: String;
  host?: UserUpdateOneRequiredWithoutHostingExperiencesInput;
  pricePerPerson?: Int;
  reviews?: ReviewUpdateManyWithoutExperienceInput;
  preview?: PictureUpdateOneRequiredInput;
  popularity?: Int;
}

export interface ViewsCreateOneWithoutPlaceInput {
  create?: ViewsCreateWithoutPlaceInput;
  connect?: ViewsWhereUniqueInput;
}

export interface ExperienceUpsertWithoutLocationInput {
  update: ExperienceUpdateWithoutLocationDataInput;
  create: ExperienceCreateWithoutLocationInput;
}

export interface PoliciesCreateOneWithoutPlaceInput {
  create?: PoliciesCreateWithoutPlaceInput;
  connect?: PoliciesWhereUniqueInput;
}

export interface LocationUpsertWithoutUserInput {
  update: LocationUpdateWithoutUserDataInput;
  create: LocationCreateWithoutUserInput;
}

export interface BookingCreateManyWithoutPlaceInput {
  create?: BookingCreateWithoutPlaceInput[] | BookingCreateWithoutPlaceInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
}

export interface UserUpsertWithoutOwnedPlacesInput {
  update: UserUpdateWithoutOwnedPlacesDataInput;
  create: UserCreateWithoutOwnedPlacesInput;
}

export interface PaymentAccountCreateManyWithoutUserInput {
  create?:
    | PaymentAccountCreateWithoutUserInput[]
    | PaymentAccountCreateWithoutUserInput;
  connect?: PaymentAccountWhereUniqueInput[] | PaymentAccountWhereUniqueInput;
}

export interface PlaceUpsertWithoutBookingsInput {
  update: PlaceUpdateWithoutBookingsDataInput;
  create: PlaceCreateWithoutBookingsInput;
}

export interface BookingCreateOneWithoutPaymentInput {
  create?: BookingCreateWithoutPaymentInput;
  connect?: BookingWhereUniqueInput;
}

export interface BookingUpsertWithWhereUniqueWithoutBookeeInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutBookeeDataInput;
  create: BookingCreateWithoutBookeeInput;
}

export interface CreditCardInformationCreateOneWithoutPaymentAccountInput {
  create?: CreditCardInformationCreateWithoutPaymentAccountInput;
  connect?: CreditCardInformationWhereUniqueInput;
}

export interface UserUpsertWithoutLocationInput {
  update: UserUpdateWithoutLocationDataInput;
  create: UserCreateWithoutLocationInput;
}

export interface UserCreateOneWithoutReceivedMessagesInput {
  create?: UserCreateWithoutReceivedMessagesInput;
  connect?: UserWhereUniqueInput;
}

export interface LocationUpsertWithoutPlaceInput {
  update: LocationUpdateWithoutPlaceDataInput;
  create: LocationCreateWithoutPlaceInput;
}

export interface ExperienceCreateManyWithoutHostInput {
  create?:
    | ExperienceCreateWithoutHostInput[]
    | ExperienceCreateWithoutHostInput;
  connect?: ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput;
}

export interface PlaceUpsertWithWhereUniqueWithoutHostInput {
  where: PlaceWhereUniqueInput;
  update: PlaceUpdateWithoutHostDataInput;
  create: PlaceCreateWithoutHostInput;
}

export interface RestaurantCreateOneWithoutLocationInput {
  create?: RestaurantCreateWithoutLocationInput;
  connect?: RestaurantWhereUniqueInput;
}

export interface UserUpsertWithoutHostingExperiencesInput {
  update: UserUpdateWithoutHostingExperiencesDataInput;
  create: UserCreateWithoutHostingExperiencesInput;
}

export interface ViewsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ViewsWhereInput;
  AND?: ViewsSubscriptionWhereInput[] | ViewsSubscriptionWhereInput;
  OR?: ViewsSubscriptionWhereInput[] | ViewsSubscriptionWhereInput;
  NOT?: ViewsSubscriptionWhereInput[] | ViewsSubscriptionWhereInput;
}

export interface ExperienceUpsertWithoutReviewsInput {
  update: ExperienceUpdateWithoutReviewsDataInput;
  create: ExperienceCreateWithoutReviewsInput;
}

export interface PoliciesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PoliciesWhereInput;
  AND?: PoliciesSubscriptionWhereInput[] | PoliciesSubscriptionWhereInput;
  OR?: PoliciesSubscriptionWhereInput[] | PoliciesSubscriptionWhereInput;
  NOT?: PoliciesSubscriptionWhereInput[] | PoliciesSubscriptionWhereInput;
}

export interface ReviewUpsertWithWhereUniqueWithoutPlaceInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutPlaceDataInput;
  create: ReviewCreateWithoutPlaceInput;
}

export interface PaymentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PaymentWhereInput;
  AND?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
  OR?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
  NOT?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
}

export interface PlaceUpsertWithoutAmenitiesInput {
  update: PlaceUpdateWithoutAmenitiesDataInput;
  create: PlaceCreateWithoutAmenitiesInput;
}

export interface LocationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LocationWhereInput;
  AND?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  OR?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  NOT?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
}

export interface AmenitiesUpdateManyMutationInput {
  elevator?: Boolean;
  petsAllowed?: Boolean;
  internet?: Boolean;
  kitchen?: Boolean;
  wirelessInternet?: Boolean;
  familyKidFriendly?: Boolean;
  freeParkingOnPremises?: Boolean;
  hotTub?: Boolean;
  pool?: Boolean;
  smokingAllowed?: Boolean;
  wheelchairAccessible?: Boolean;
  breakfast?: Boolean;
  cableTv?: Boolean;
  suitableForEvents?: Boolean;
  dryer?: Boolean;
  washer?: Boolean;
  indoorFireplace?: Boolean;
  tv?: Boolean;
  heating?: Boolean;
  hangers?: Boolean;
  iron?: Boolean;
  hairDryer?: Boolean;
  doorman?: Boolean;
  paidParkingOffPremises?: Boolean;
  freeParkingOnStreet?: Boolean;
  gym?: Boolean;
  airConditioning?: Boolean;
  shampoo?: Boolean;
  essentials?: Boolean;
  laptopFriendlyWorkspace?: Boolean;
  privateEntrance?: Boolean;
  buzzerWirelessIntercom?: Boolean;
  babyBath?: Boolean;
  babyMonitor?: Boolean;
  babysitterRecommendations?: Boolean;
  bathtub?: Boolean;
  changingTable?: Boolean;
  childrensBooksAndToys?: Boolean;
  childrensDinnerware?: Boolean;
  crib?: Boolean;
}

export interface BookingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BookingWhereInput;
  AND?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
  OR?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
  NOT?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
}

export interface HouseRulesUpdateManyMutationInput {
  suitableForChildren?: Boolean;
  suitableForInfants?: Boolean;
  petsAllowed?: Boolean;
  smokingAllowed?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  additionalRules?: String;
}

export interface PlaceUpdateOneRequiredWithoutViewsInput {
  create?: PlaceCreateWithoutViewsInput;
  update?: PlaceUpdateWithoutViewsDataInput;
  upsert?: PlaceUpsertWithoutViewsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface HouseRulesUpdateInput {
  suitableForChildren?: Boolean;
  suitableForInfants?: Boolean;
  petsAllowed?: Boolean;
  smokingAllowed?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  additionalRules?: String;
}

export interface UserUpdateInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  password?: String;
  phone?: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost?: Boolean;
  ownedPlaces?: PlaceUpdateManyWithoutHostInput;
  location?: LocationUpdateOneWithoutUserInput;
  bookings?: BookingUpdateManyWithoutBookeeInput;
  paymentAccount?: PaymentAccountUpdateManyWithoutUserInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receivedMessages?: MessageUpdateManyWithoutToInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  profilePicture?: PictureUpdateOneInput;
  hostingExperiences?: ExperienceUpdateManyWithoutHostInput;
}

export interface BookingCreateInput {
  bookee: UserCreateOneWithoutBookingsInput;
  place: PlaceCreateOneWithoutBookingsInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
  payment?: PaymentCreateOneWithoutBookingInput;
}

export type GuestRequirementsWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BookingUpdateInput {
  bookee?: UserUpdateOneRequiredWithoutBookingsInput;
  place?: PlaceUpdateOneRequiredWithoutBookingsInput;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  payment?: PaymentUpdateOneWithoutBookingInput;
}

export interface LocationCreateOneWithoutRestaurantInput {
  create?: LocationCreateWithoutRestaurantInput;
  connect?: LocationWhereUniqueInput;
}

export interface BookingUpdateManyMutationInput {
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
}

export interface PricingUpdateInput {
  place?: PlaceUpdateOneRequiredWithoutPricingInput;
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight?: Int;
  smartPricing?: Boolean;
  basePrice?: Int;
  averageWeekly?: Int;
  averageMonthly?: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export interface CityCreateInput {
  name: String;
  neighbourhoods?: NeighbourhoodCreateManyWithoutCityInput;
}

export interface PlaceUpdateWithoutPoliciesDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneRequiredWithoutPlaceInput;
  host?: UserUpdateOneRequiredWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneRequiredWithoutPlaceInput;
  location?: LocationUpdateOneRequiredWithoutPlaceInput;
  views?: ViewsUpdateOneRequiredWithoutPlaceInput;
  guestRequirements?: GuestRequirementsUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface NeighbourhoodCreateManyWithoutCityInput {
  create?:
    | NeighbourhoodCreateWithoutCityInput[]
    | NeighbourhoodCreateWithoutCityInput;
  connect?: NeighbourhoodWhereUniqueInput[] | NeighbourhoodWhereUniqueInput;
}

export interface PlaceUpdateManyMutationInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  popularity?: Int;
}

export interface NeighbourhoodCreateWithoutCityInput {
  locations?: LocationCreateManyWithoutNeighbourHoodInput;
  name: String;
  slug: String;
  homePreview?: PictureCreateOneInput;
  featured: Boolean;
  popularity: Int;
}

export interface PaypalInformationUpdateManyMutationInput {
  email?: String;
}

export interface LocationCreateManyWithoutNeighbourHoodInput {
  create?:
    | LocationCreateWithoutNeighbourHoodInput[]
    | LocationCreateWithoutNeighbourHoodInput;
  connect?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
}

export interface PaymentAccountCreateOneWithoutPaypalInput {
  create?: PaymentAccountCreateWithoutPaypalInput;
  connect?: PaymentAccountWhereUniqueInput;
}

export interface LocationCreateWithoutNeighbourHoodInput {
  lat: Float;
  lng: Float;
  user?: UserCreateOneWithoutLocationInput;
  place?: PlaceCreateOneWithoutLocationInput;
  address: String;
  directions: String;
  experience?: ExperienceCreateOneWithoutLocationInput;
  restaurant?: RestaurantCreateOneWithoutLocationInput;
}

export interface PaymentUpdateInput {
  serviceFee?: Float;
  placePrice?: Float;
  totalPrice?: Float;
  booking?: BookingUpdateOneRequiredWithoutPaymentInput;
  paymentMethod?: PaymentAccountUpdateOneRequiredWithoutPaymentsInput;
}

export interface CityUpdateInput {
  name?: String;
  neighbourhoods?: NeighbourhoodUpdateManyWithoutCityInput;
}

export interface NotificationUpdateInput {
  type?: NOTIFICATION_TYPE;
  user?: UserUpdateOneRequiredWithoutNotificationsInput;
  link?: String;
  readDate?: DateTimeInput;
}

export interface NeighbourhoodUpdateManyWithoutCityInput {
  create?:
    | NeighbourhoodCreateWithoutCityInput[]
    | NeighbourhoodCreateWithoutCityInput;
  delete?: NeighbourhoodWhereUniqueInput[] | NeighbourhoodWhereUniqueInput;
  connect?: NeighbourhoodWhereUniqueInput[] | NeighbourhoodWhereUniqueInput;
  disconnect?: NeighbourhoodWhereUniqueInput[] | NeighbourhoodWhereUniqueInput;
  update?:
    | NeighbourhoodUpdateWithWhereUniqueWithoutCityInput[]
    | NeighbourhoodUpdateWithWhereUniqueWithoutCityInput;
  upsert?:
    | NeighbourhoodUpsertWithWhereUniqueWithoutCityInput[]
    | NeighbourhoodUpsertWithWhereUniqueWithoutCityInput;
}

export interface NeighbourhoodCreateInput {
  locations?: LocationCreateManyWithoutNeighbourHoodInput;
  name: String;
  slug: String;
  homePreview?: PictureCreateOneInput;
  city: CityCreateOneWithoutNeighbourhoodsInput;
  featured: Boolean;
  popularity: Int;
}

export interface NeighbourhoodUpdateWithWhereUniqueWithoutCityInput {
  where: NeighbourhoodWhereUniqueInput;
  data: NeighbourhoodUpdateWithoutCityDataInput;
}

export interface ReviewCreateManyWithoutPlaceInput {
  create?: ReviewCreateWithoutPlaceInput[] | ReviewCreateWithoutPlaceInput;
  connect?: ReviewWhereUniqueInput[] | ReviewWhereUniqueInput;
}

export interface NeighbourhoodUpdateWithoutCityDataInput {
  locations?: LocationUpdateManyWithoutNeighbourHoodInput;
  name?: String;
  slug?: String;
  homePreview?: PictureUpdateOneInput;
  featured?: Boolean;
  popularity?: Int;
}

export interface PlaceCreateManyWithoutHostInput {
  create?: PlaceCreateWithoutHostInput[] | PlaceCreateWithoutHostInput;
  connect?: PlaceWhereUniqueInput[] | PlaceWhereUniqueInput;
}

export interface LocationUpdateManyWithoutNeighbourHoodInput {
  create?:
    | LocationCreateWithoutNeighbourHoodInput[]
    | LocationCreateWithoutNeighbourHoodInput;
  delete?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
  connect?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
  disconnect?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
  update?:
    | LocationUpdateWithWhereUniqueWithoutNeighbourHoodInput[]
    | LocationUpdateWithWhereUniqueWithoutNeighbourHoodInput;
  upsert?:
    | LocationUpsertWithWhereUniqueWithoutNeighbourHoodInput[]
    | LocationUpsertWithWhereUniqueWithoutNeighbourHoodInput;
}

export interface NeighbourhoodCreateOneWithoutLocationsInput {
  create?: NeighbourhoodCreateWithoutLocationsInput;
  connect?: NeighbourhoodWhereUniqueInput;
}

export interface LocationUpdateWithWhereUniqueWithoutNeighbourHoodInput {
  where: LocationWhereUniqueInput;
  data: LocationUpdateWithoutNeighbourHoodDataInput;
}

export interface BookingCreateManyWithoutBookeeInput {
  create?: BookingCreateWithoutBookeeInput[] | BookingCreateWithoutBookeeInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
}

export interface LocationUpdateWithoutNeighbourHoodDataInput {
  lat?: Float;
  lng?: Float;
  user?: UserUpdateOneWithoutLocationInput;
  place?: PlaceUpdateOneWithoutLocationInput;
  address?: String;
  directions?: String;
  experience?: ExperienceUpdateOneWithoutLocationInput;
  restaurant?: RestaurantUpdateOneWithoutLocationInput;
}

export interface PlaceCreateOneWithoutLocationInput {
  create?: PlaceCreateWithoutLocationInput;
  connect?: PlaceWhereUniqueInput;
}

export interface LocationUpsertWithWhereUniqueWithoutNeighbourHoodInput {
  where: LocationWhereUniqueInput;
  update: LocationUpdateWithoutNeighbourHoodDataInput;
  create: LocationCreateWithoutNeighbourHoodInput;
}

export interface HouseRulesCreateOneInput {
  create?: HouseRulesCreateInput;
  connect?: HouseRulesWhereUniqueInput;
}

export interface NeighbourhoodUpsertWithWhereUniqueWithoutCityInput {
  where: NeighbourhoodWhereUniqueInput;
  update: NeighbourhoodUpdateWithoutCityDataInput;
  create: NeighbourhoodCreateWithoutCityInput;
}

export interface PaymentCreateManyWithoutPaymentMethodInput {
  create?:
    | PaymentCreateWithoutPaymentMethodInput[]
    | PaymentCreateWithoutPaymentMethodInput;
  connect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
}

export interface CityUpdateManyMutationInput {
  name?: String;
}

export interface MessageCreateManyWithoutFromInput {
  create?: MessageCreateWithoutFromInput[] | MessageCreateWithoutFromInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
}

export interface CreditCardInformationCreateInput {
  cardNumber: String;
  expiresOnMonth: Int;
  expiresOnYear: Int;
  securityCode: String;
  firstName: String;
  lastName: String;
  postalCode: String;
  country: String;
  paymentAccount?: PaymentAccountCreateOneWithoutCreditcardInput;
}

export interface LocationCreateOneWithoutExperienceInput {
  create?: LocationCreateWithoutExperienceInput;
  connect?: LocationWhereUniqueInput;
}

export interface PaymentAccountCreateOneWithoutCreditcardInput {
  create?: PaymentAccountCreateWithoutCreditcardInput;
  connect?: PaymentAccountWhereUniqueInput;
}

export interface PaypalInformationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  paymentAccount?: PaymentAccountWhereInput;
  AND?: PaypalInformationWhereInput[] | PaypalInformationWhereInput;
  OR?: PaypalInformationWhereInput[] | PaypalInformationWhereInput;
  NOT?: PaypalInformationWhereInput[] | PaypalInformationWhereInput;
}

export interface PaymentAccountCreateWithoutCreditcardInput {
  type?: PAYMENT_PROVIDER;
  user: UserCreateOneWithoutPaymentAccountInput;
  payments?: PaymentCreateManyWithoutPaymentMethodInput;
  paypal?: PaypalInformationCreateOneWithoutPaymentAccountInput;
}

export interface CityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  neighbourhoods_every?: NeighbourhoodWhereInput;
  neighbourhoods_some?: NeighbourhoodWhereInput;
  neighbourhoods_none?: NeighbourhoodWhereInput;
  AND?: CityWhereInput[] | CityWhereInput;
  OR?: CityWhereInput[] | CityWhereInput;
  NOT?: CityWhereInput[] | CityWhereInput;
}

export interface CreditCardInformationUpdateInput {
  cardNumber?: String;
  expiresOnMonth?: Int;
  expiresOnYear?: Int;
  securityCode?: String;
  firstName?: String;
  lastName?: String;
  postalCode?: String;
  country?: String;
  paymentAccount?: PaymentAccountUpdateOneWithoutCreditcardInput;
}

export interface PlaceUpsertWithoutViewsInput {
  update: PlaceUpdateWithoutViewsDataInput;
  create: PlaceCreateWithoutViewsInput;
}

export interface PaymentAccountUpdateOneWithoutCreditcardInput {
  create?: PaymentAccountCreateWithoutCreditcardInput;
  update?: PaymentAccountUpdateWithoutCreditcardDataInput;
  upsert?: PaymentAccountUpsertWithoutCreditcardInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PaymentAccountWhereUniqueInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  responseRate?: Float;
  responseRate_not?: Float;
  responseRate_in?: Float[] | Float;
  responseRate_not_in?: Float[] | Float;
  responseRate_lt?: Float;
  responseRate_lte?: Float;
  responseRate_gt?: Float;
  responseRate_gte?: Float;
  responseTime?: Int;
  responseTime_not?: Int;
  responseTime_in?: Int[] | Int;
  responseTime_not_in?: Int[] | Int;
  responseTime_lt?: Int;
  responseTime_lte?: Int;
  responseTime_gt?: Int;
  responseTime_gte?: Int;
  isSuperHost?: Boolean;
  isSuperHost_not?: Boolean;
  ownedPlaces_every?: PlaceWhereInput;
  ownedPlaces_some?: PlaceWhereInput;
  ownedPlaces_none?: PlaceWhereInput;
  location?: LocationWhereInput;
  bookings_every?: BookingWhereInput;
  bookings_some?: BookingWhereInput;
  bookings_none?: BookingWhereInput;
  paymentAccount_every?: PaymentAccountWhereInput;
  paymentAccount_some?: PaymentAccountWhereInput;
  paymentAccount_none?: PaymentAccountWhereInput;
  sentMessages_every?: MessageWhereInput;
  sentMessages_some?: MessageWhereInput;
  sentMessages_none?: MessageWhereInput;
  receivedMessages_every?: MessageWhereInput;
  receivedMessages_some?: MessageWhereInput;
  receivedMessages_none?: MessageWhereInput;
  notifications_every?: NotificationWhereInput;
  notifications_some?: NotificationWhereInput;
  notifications_none?: NotificationWhereInput;
  profilePicture?: PictureWhereInput;
  hostingExperiences_every?: ExperienceWhereInput;
  hostingExperiences_some?: ExperienceWhereInput;
  hostingExperiences_none?: ExperienceWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface PaymentAccountUpdateWithoutCreditcardDataInput {
  type?: PAYMENT_PROVIDER;
  user?: UserUpdateOneRequiredWithoutPaymentAccountInput;
  payments?: PaymentUpdateManyWithoutPaymentMethodInput;
  paypal?: PaypalInformationUpdateOneWithoutPaymentAccountInput;
}

export interface PlaceUpsertWithoutPricingInput {
  update: PlaceUpdateWithoutPricingDataInput;
  create: PlaceCreateWithoutPricingInput;
}

export interface PaymentAccountUpsertWithoutCreditcardInput {
  update: PaymentAccountUpdateWithoutCreditcardDataInput;
  create: PaymentAccountCreateWithoutCreditcardInput;
}

export interface PlaceCreateWithoutPoliciesInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface CreditCardInformationUpdateManyMutationInput {
  cardNumber?: String;
  expiresOnMonth?: Int;
  expiresOnYear?: Int;
  securityCode?: String;
  firstName?: String;
  lastName?: String;
  postalCode?: String;
  country?: String;
}

export interface PaymentAccountUpdateOneRequiredWithoutPaypalInput {
  create?: PaymentAccountCreateWithoutPaypalInput;
  update?: PaymentAccountUpdateWithoutPaypalDataInput;
  upsert?: PaymentAccountUpsertWithoutPaypalInput;
  connect?: PaymentAccountWhereUniqueInput;
}

export interface ExperienceCreateInput {
  category?: ExperienceCategoryCreateOneWithoutExperienceInput;
  title: String;
  host: UserCreateOneWithoutHostingExperiencesInput;
  location: LocationCreateOneWithoutExperienceInput;
  pricePerPerson: Int;
  reviews?: ReviewCreateManyWithoutExperienceInput;
  preview: PictureCreateOneInput;
  popularity: Int;
}

export interface UserUpsertWithoutNotificationsInput {
  update: UserUpdateWithoutNotificationsDataInput;
  create: UserCreateWithoutNotificationsInput;
}

export interface ExperienceUpdateInput {
  category?: ExperienceCategoryUpdateOneWithoutExperienceInput;
  title?: String;
  host?: UserUpdateOneRequiredWithoutHostingExperiencesInput;
  location?: LocationUpdateOneRequiredWithoutExperienceInput;
  pricePerPerson?: Int;
  reviews?: ReviewUpdateManyWithoutExperienceInput;
  preview?: PictureUpdateOneRequiredInput;
  popularity?: Int;
}

export interface PricingCreateOneWithoutPlaceInput {
  create?: PricingCreateWithoutPlaceInput;
  connect?: PricingWhereUniqueInput;
}

export interface ExperienceUpdateManyMutationInput {
  title?: String;
  pricePerPerson?: Int;
  popularity?: Int;
}

export interface UserCreateOneWithoutOwnedPlacesInput {
  create?: UserCreateWithoutOwnedPlacesInput;
  connect?: UserWhereUniqueInput;
}

export interface ExperienceCategoryCreateInput {
  mainColor?: String;
  name: String;
  experience?: ExperienceCreateOneWithoutCategoryInput;
}

export interface UserCreateOneWithoutBookingsInput {
  create?: UserCreateWithoutBookingsInput;
  connect?: UserWhereUniqueInput;
}

export interface ExperienceCreateOneWithoutCategoryInput {
  create?: ExperienceCreateWithoutCategoryInput;
  connect?: ExperienceWhereUniqueInput;
}

export interface NotificationCreateManyWithoutUserInput {
  create?:
    | NotificationCreateWithoutUserInput[]
    | NotificationCreateWithoutUserInput;
  connect?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
}

export interface ExperienceCreateWithoutCategoryInput {
  title: String;
  host: UserCreateOneWithoutHostingExperiencesInput;
  location: LocationCreateOneWithoutExperienceInput;
  pricePerPerson: Int;
  reviews?: ReviewCreateManyWithoutExperienceInput;
  preview: PictureCreateOneInput;
  popularity: Int;
}

export interface PictureSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PictureWhereInput;
  AND?: PictureSubscriptionWhereInput[] | PictureSubscriptionWhereInput;
  OR?: PictureSubscriptionWhereInput[] | PictureSubscriptionWhereInput;
  NOT?: PictureSubscriptionWhereInput[] | PictureSubscriptionWhereInput;
}

export interface ExperienceCategoryUpdateInput {
  mainColor?: String;
  name?: String;
  experience?: ExperienceUpdateOneWithoutCategoryInput;
}

export interface PlaceCreateOneWithoutViewsInput {
  create?: PlaceCreateWithoutViewsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface ExperienceUpdateOneWithoutCategoryInput {
  create?: ExperienceCreateWithoutCategoryInput;
  update?: ExperienceUpdateWithoutCategoryDataInput;
  upsert?: ExperienceUpsertWithoutCategoryInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExperienceWhereUniqueInput;
}

export interface PricingCreateInput {
  place: PlaceCreateOneWithoutPricingInput;
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight: Int;
  smartPricing?: Boolean;
  basePrice: Int;
  averageWeekly: Int;
  averageMonthly: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export interface ExperienceUpdateWithoutCategoryDataInput {
  title?: String;
  host?: UserUpdateOneRequiredWithoutHostingExperiencesInput;
  location?: LocationUpdateOneRequiredWithoutExperienceInput;
  pricePerPerson?: Int;
  reviews?: ReviewUpdateManyWithoutExperienceInput;
  preview?: PictureUpdateOneRequiredInput;
  popularity?: Int;
}

export type PricingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExperienceUpsertWithoutCategoryInput {
  update: ExperienceUpdateWithoutCategoryDataInput;
  create: ExperienceCreateWithoutCategoryInput;
}

export interface ExperienceCategoryCreateOneWithoutExperienceInput {
  create?: ExperienceCategoryCreateWithoutExperienceInput;
  connect?: ExperienceCategoryWhereUniqueInput;
}

export interface ExperienceCategoryUpdateManyMutationInput {
  mainColor?: String;
  name?: String;
}

export interface GuestRequirementsCreateOneWithoutPlaceInput {
  create?: GuestRequirementsCreateWithoutPlaceInput;
  connect?: GuestRequirementsWhereUniqueInput;
}

export interface GuestRequirementsCreateInput {
  govIssuedId?: Boolean;
  recommendationsFromOtherHosts?: Boolean;
  guestTripInformation?: Boolean;
  place: PlaceCreateOneWithoutGuestRequirementsInput;
}

export interface PictureCreateManyInput {
  create?: PictureCreateInput[] | PictureCreateInput;
  connect?: PictureWhereUniqueInput[] | PictureWhereUniqueInput;
}

export interface PlaceCreateOneWithoutGuestRequirementsInput {
  create?: PlaceCreateWithoutGuestRequirementsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface RestaurantUpdateInput {
  title?: String;
  avgPricePerPerson?: Int;
  pictures?: PictureUpdateManyInput;
  location?: LocationUpdateOneRequiredWithoutRestaurantInput;
  isCurated?: Boolean;
  slug?: String;
  popularity?: Int;
}

export interface PlaceCreateWithoutGuestRequirementsInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface NotificationCreateInput {
  type?: NOTIFICATION_TYPE;
  user: UserCreateOneWithoutNotificationsInput;
  link: String;
  readDate: DateTimeInput;
}

export interface PlaceUpsertWithoutGuestRequirementsInput {
  update: PlaceUpdateWithoutGuestRequirementsDataInput;
  create: PlaceCreateWithoutGuestRequirementsInput;
}

export interface PlaceUpdateWithoutGuestRequirementsDataInput {
  name?: String;
  size?: PLACE_SIZES;
  shortDescription?: String;
  description?: String;
  slug?: String;
  maxGuests?: Int;
  numBedrooms?: Int;
  numBeds?: Int;
  numBaths?: Int;
  reviews?: ReviewUpdateManyWithoutPlaceInput;
  amenities?: AmenitiesUpdateOneRequiredWithoutPlaceInput;
  host?: UserUpdateOneRequiredWithoutOwnedPlacesInput;
  pricing?: PricingUpdateOneRequiredWithoutPlaceInput;
  location?: LocationUpdateOneRequiredWithoutPlaceInput;
  views?: ViewsUpdateOneRequiredWithoutPlaceInput;
  policies?: PoliciesUpdateOneWithoutPlaceInput;
  houseRules?: HouseRulesUpdateOneInput;
  bookings?: BookingUpdateManyWithoutPlaceInput;
  pictures?: PictureUpdateManyInput;
  popularity?: Int;
}

export interface PlaceUpdateOneRequiredWithoutGuestRequirementsInput {
  create?: PlaceCreateWithoutGuestRequirementsInput;
  update?: PlaceUpdateWithoutGuestRequirementsDataInput;
  upsert?: PlaceUpsertWithoutGuestRequirementsInput;
  connect?: PlaceWhereUniqueInput;
}

export interface GuestRequirementsUpdateInput {
  govIssuedId?: Boolean;
  recommendationsFromOtherHosts?: Boolean;
  guestTripInformation?: Boolean;
  place?: PlaceUpdateOneRequiredWithoutGuestRequirementsInput;
}

export interface CityCreateOneWithoutNeighbourhoodsInput {
  create?: CityCreateWithoutNeighbourhoodsInput;
  connect?: CityWhereUniqueInput;
}

export interface PlaceCreateInput {
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  reviews?: ReviewCreateManyWithoutPlaceInput;
  amenities: AmenitiesCreateOneWithoutPlaceInput;
  host: UserCreateOneWithoutOwnedPlacesInput;
  pricing: PricingCreateOneWithoutPlaceInput;
  location: LocationCreateOneWithoutPlaceInput;
  views: ViewsCreateOneWithoutPlaceInput;
  guestRequirements?: GuestRequirementsCreateOneWithoutPlaceInput;
  policies?: PoliciesCreateOneWithoutPlaceInput;
  houseRules?: HouseRulesCreateOneInput;
  bookings?: BookingCreateManyWithoutPlaceInput;
  pictures?: PictureCreateManyInput;
  popularity: Int;
}

export interface NeighbourhoodWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  locations_every?: LocationWhereInput;
  locations_some?: LocationWhereInput;
  locations_none?: LocationWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  homePreview?: PictureWhereInput;
  city?: CityWhereInput;
  featured?: Boolean;
  featured_not?: Boolean;
  popularity?: Int;
  popularity_not?: Int;
  popularity_in?: Int[] | Int;
  popularity_not_in?: Int[] | Int;
  popularity_lt?: Int;
  popularity_lte?: Int;
  popularity_gt?: Int;
  popularity_gte?: Int;
  AND?: NeighbourhoodWhereInput[] | NeighbourhoodWhereInput;
  OR?: NeighbourhoodWhereInput[] | NeighbourhoodWhereInput;
  NOT?: NeighbourhoodWhereInput[] | NeighbourhoodWhereInput;
}

export interface PaypalInformationCreateOneWithoutPaymentAccountInput {
  create?: PaypalInformationCreateWithoutPaymentAccountInput;
  connect?: PaypalInformationWhereUniqueInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface ViewsPreviousValues {
  id: ID_Output;
  lastWeek: Int;
}

export interface ViewsPreviousValuesPromise
  extends Promise<ViewsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  lastWeek: () => Promise<Int>;
}

export interface ViewsPreviousValuesSubscription
  extends Promise<AsyncIterator<ViewsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lastWeek: () => Promise<AsyncIterator<Int>>;
}

export interface CityConnection {}

export interface CityConnectionPromise
  extends Promise<CityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CityEdge>>() => T;
  aggregate: <T = AggregateCityPromise>() => T;
}

export interface CityConnectionSubscription
  extends Promise<AsyncIterator<CityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCitySubscription>() => T;
}

export interface Experience {
  id: ID_Output;
  title: String;
  pricePerPerson: Int;
  popularity: Int;
}

export interface ExperiencePromise extends Promise<Experience>, Fragmentable {
  id: () => Promise<ID_Output>;
  category: <T = ExperienceCategoryPromise>() => T;
  title: () => Promise<String>;
  host: <T = UserPromise>() => T;
  location: <T = LocationPromise>() => T;
  pricePerPerson: () => Promise<Int>;
  reviews: <T = FragmentableArray<Review>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  preview: <T = PicturePromise>() => T;
  popularity: () => Promise<Int>;
}

export interface ExperienceSubscription
  extends Promise<AsyncIterator<Experience>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: <T = ExperienceCategorySubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  host: <T = UserSubscription>() => T;
  location: <T = LocationSubscription>() => T;
  pricePerPerson: () => Promise<AsyncIterator<Int>>;
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  preview: <T = PictureSubscription>() => T;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateBooking {
  count: Int;
}

export interface AggregateBookingPromise
  extends Promise<AggregateBooking>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookingSubscription
  extends Promise<AsyncIterator<AggregateBooking>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExperienceCategory {
  id: ID_Output;
  mainColor: String;
  name: String;
}

export interface ExperienceCategoryPromise
  extends Promise<ExperienceCategory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  mainColor: () => Promise<String>;
  name: () => Promise<String>;
  experience: <T = ExperiencePromise>() => T;
}

export interface ExperienceCategorySubscription
  extends Promise<AsyncIterator<ExperienceCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  mainColor: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  experience: <T = ExperienceSubscription>() => T;
}

export interface CityEdge {
  cursor: String;
}

export interface CityEdgePromise extends Promise<CityEdge>, Fragmentable {
  node: <T = CityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CityEdgeSubscription
  extends Promise<AsyncIterator<CityEdge>>,
    Fragmentable {
  node: <T = CitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ReviewPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
}

export interface ReviewPreviousValuesPromise
  extends Promise<ReviewPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  stars: () => Promise<Int>;
  accuracy: () => Promise<Int>;
  location: () => Promise<Int>;
  checkIn: () => Promise<Int>;
  value: () => Promise<Int>;
  cleanliness: () => Promise<Int>;
  communication: () => Promise<Int>;
}

export interface ReviewPreviousValuesSubscription
  extends Promise<AsyncIterator<ReviewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  stars: () => Promise<AsyncIterator<Int>>;
  accuracy: () => Promise<AsyncIterator<Int>>;
  location: () => Promise<AsyncIterator<Int>>;
  checkIn: () => Promise<AsyncIterator<Int>>;
  value: () => Promise<AsyncIterator<Int>>;
  cleanliness: () => Promise<AsyncIterator<Int>>;
  communication: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface BookingEdge {
  cursor: String;
}

export interface BookingEdgePromise extends Promise<BookingEdge>, Fragmentable {
  node: <T = BookingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookingEdgeSubscription
  extends Promise<AsyncIterator<BookingEdge>>,
    Fragmentable {
  node: <T = BookingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Review {
  id: ID_Output;
  createdAt: DateTimeOutput;
  text: String;
  stars: Int;
  accuracy: Int;
  location: Int;
  checkIn: Int;
  value: Int;
  cleanliness: Int;
  communication: Int;
}

export interface ReviewPromise extends Promise<Review>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  stars: () => Promise<Int>;
  accuracy: () => Promise<Int>;
  location: () => Promise<Int>;
  checkIn: () => Promise<Int>;
  value: () => Promise<Int>;
  cleanliness: () => Promise<Int>;
  communication: () => Promise<Int>;
  place: <T = PlacePromise>() => T;
  experience: <T = ExperiencePromise>() => T;
}

export interface ReviewSubscription
  extends Promise<AsyncIterator<Review>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  stars: () => Promise<AsyncIterator<Int>>;
  accuracy: () => Promise<AsyncIterator<Int>>;
  location: () => Promise<AsyncIterator<Int>>;
  checkIn: () => Promise<AsyncIterator<Int>>;
  value: () => Promise<AsyncIterator<Int>>;
  cleanliness: () => Promise<AsyncIterator<Int>>;
  communication: () => Promise<AsyncIterator<Int>>;
  place: <T = PlaceSubscription>() => T;
  experience: <T = ExperienceSubscription>() => T;
}

export interface ViewsConnection {}

export interface ViewsConnectionPromise
  extends Promise<ViewsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ViewsEdge>>() => T;
  aggregate: <T = AggregateViewsPromise>() => T;
}

export interface ViewsConnectionSubscription
  extends Promise<AsyncIterator<ViewsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ViewsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateViewsSubscription>() => T;
}

export interface AggregateViews {
  count: Int;
}

export interface AggregateViewsPromise
  extends Promise<AggregateViews>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateViewsSubscription
  extends Promise<AsyncIterator<AggregateViews>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookingConnection {}

export interface BookingConnectionPromise
  extends Promise<BookingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookingEdge>>() => T;
  aggregate: <T = AggregateBookingPromise>() => T;
}

export interface BookingConnectionSubscription
  extends Promise<AsyncIterator<BookingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookingSubscription>() => T;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface Amenities {
  id: ID_Output;
  elevator: Boolean;
  petsAllowed: Boolean;
  internet: Boolean;
  kitchen: Boolean;
  wirelessInternet: Boolean;
  familyKidFriendly: Boolean;
  freeParkingOnPremises: Boolean;
  hotTub: Boolean;
  pool: Boolean;
  smokingAllowed: Boolean;
  wheelchairAccessible: Boolean;
  breakfast: Boolean;
  cableTv: Boolean;
  suitableForEvents: Boolean;
  dryer: Boolean;
  washer: Boolean;
  indoorFireplace: Boolean;
  tv: Boolean;
  heating: Boolean;
  hangers: Boolean;
  iron: Boolean;
  hairDryer: Boolean;
  doorman: Boolean;
  paidParkingOffPremises: Boolean;
  freeParkingOnStreet: Boolean;
  gym: Boolean;
  airConditioning: Boolean;
  shampoo: Boolean;
  essentials: Boolean;
  laptopFriendlyWorkspace: Boolean;
  privateEntrance: Boolean;
  buzzerWirelessIntercom: Boolean;
  babyBath: Boolean;
  babyMonitor: Boolean;
  babysitterRecommendations: Boolean;
  bathtub: Boolean;
  changingTable: Boolean;
  childrensBooksAndToys: Boolean;
  childrensDinnerware: Boolean;
  crib: Boolean;
}

export interface AmenitiesPromise extends Promise<Amenities>, Fragmentable {
  id: () => Promise<ID_Output>;
  place: <T = PlacePromise>() => T;
  elevator: () => Promise<Boolean>;
  petsAllowed: () => Promise<Boolean>;
  internet: () => Promise<Boolean>;
  kitchen: () => Promise<Boolean>;
  wirelessInternet: () => Promise<Boolean>;
  familyKidFriendly: () => Promise<Boolean>;
  freeParkingOnPremises: () => Promise<Boolean>;
  hotTub: () => Promise<Boolean>;
  pool: () => Promise<Boolean>;
  smokingAllowed: () => Promise<Boolean>;
  wheelchairAccessible: () => Promise<Boolean>;
  breakfast: () => Promise<Boolean>;
  cableTv: () => Promise<Boolean>;
  suitableForEvents: () => Promise<Boolean>;
  dryer: () => Promise<Boolean>;
  washer: () => Promise<Boolean>;
  indoorFireplace: () => Promise<Boolean>;
  tv: () => Promise<Boolean>;
  heating: () => Promise<Boolean>;
  hangers: () => Promise<Boolean>;
  iron: () => Promise<Boolean>;
  hairDryer: () => Promise<Boolean>;
  doorman: () => Promise<Boolean>;
  paidParkingOffPremises: () => Promise<Boolean>;
  freeParkingOnStreet: () => Promise<Boolean>;
  gym: () => Promise<Boolean>;
  airConditioning: () => Promise<Boolean>;
  shampoo: () => Promise<Boolean>;
  essentials: () => Promise<Boolean>;
  laptopFriendlyWorkspace: () => Promise<Boolean>;
  privateEntrance: () => Promise<Boolean>;
  buzzerWirelessIntercom: () => Promise<Boolean>;
  babyBath: () => Promise<Boolean>;
  babyMonitor: () => Promise<Boolean>;
  babysitterRecommendations: () => Promise<Boolean>;
  bathtub: () => Promise<Boolean>;
  changingTable: () => Promise<Boolean>;
  childrensBooksAndToys: () => Promise<Boolean>;
  childrensDinnerware: () => Promise<Boolean>;
  crib: () => Promise<Boolean>;
}

export interface AmenitiesSubscription
  extends Promise<AsyncIterator<Amenities>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  place: <T = PlaceSubscription>() => T;
  elevator: () => Promise<AsyncIterator<Boolean>>;
  petsAllowed: () => Promise<AsyncIterator<Boolean>>;
  internet: () => Promise<AsyncIterator<Boolean>>;
  kitchen: () => Promise<AsyncIterator<Boolean>>;
  wirelessInternet: () => Promise<AsyncIterator<Boolean>>;
  familyKidFriendly: () => Promise<AsyncIterator<Boolean>>;
  freeParkingOnPremises: () => Promise<AsyncIterator<Boolean>>;
  hotTub: () => Promise<AsyncIterator<Boolean>>;
  pool: () => Promise<AsyncIterator<Boolean>>;
  smokingAllowed: () => Promise<AsyncIterator<Boolean>>;
  wheelchairAccessible: () => Promise<AsyncIterator<Boolean>>;
  breakfast: () => Promise<AsyncIterator<Boolean>>;
  cableTv: () => Promise<AsyncIterator<Boolean>>;
  suitableForEvents: () => Promise<AsyncIterator<Boolean>>;
  dryer: () => Promise<AsyncIterator<Boolean>>;
  washer: () => Promise<AsyncIterator<Boolean>>;
  indoorFireplace: () => Promise<AsyncIterator<Boolean>>;
  tv: () => Promise<AsyncIterator<Boolean>>;
  heating: () => Promise<AsyncIterator<Boolean>>;
  hangers: () => Promise<AsyncIterator<Boolean>>;
  iron: () => Promise<AsyncIterator<Boolean>>;
  hairDryer: () => Promise<AsyncIterator<Boolean>>;
  doorman: () => Promise<AsyncIterator<Boolean>>;
  paidParkingOffPremises: () => Promise<AsyncIterator<Boolean>>;
  freeParkingOnStreet: () => Promise<AsyncIterator<Boolean>>;
  gym: () => Promise<AsyncIterator<Boolean>>;
  airConditioning: () => Promise<AsyncIterator<Boolean>>;
  shampoo: () => Promise<AsyncIterator<Boolean>>;
  essentials: () => Promise<AsyncIterator<Boolean>>;
  laptopFriendlyWorkspace: () => Promise<AsyncIterator<Boolean>>;
  privateEntrance: () => Promise<AsyncIterator<Boolean>>;
  buzzerWirelessIntercom: () => Promise<AsyncIterator<Boolean>>;
  babyBath: () => Promise<AsyncIterator<Boolean>>;
  babyMonitor: () => Promise<AsyncIterator<Boolean>>;
  babysitterRecommendations: () => Promise<AsyncIterator<Boolean>>;
  bathtub: () => Promise<AsyncIterator<Boolean>>;
  changingTable: () => Promise<AsyncIterator<Boolean>>;
  childrensBooksAndToys: () => Promise<AsyncIterator<Boolean>>;
  childrensDinnerware: () => Promise<AsyncIterator<Boolean>>;
  crib: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateReview {
  count: Int;
}

export interface AggregateReviewPromise
  extends Promise<AggregateReview>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReviewSubscription
  extends Promise<AsyncIterator<AggregateReview>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AmenitiesSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface AmenitiesSubscriptionPayloadPromise
  extends Promise<AmenitiesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AmenitiesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AmenitiesPreviousValuesPromise>() => T;
}

export interface AmenitiesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AmenitiesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AmenitiesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AmenitiesPreviousValuesSubscription>() => T;
}

export interface ReviewConnection {}

export interface ReviewConnectionPromise
  extends Promise<ReviewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReviewEdge>>() => T;
  aggregate: <T = AggregateReviewPromise>() => T;
}

export interface ReviewConnectionSubscription
  extends Promise<AsyncIterator<ReviewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReviewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReviewSubscription>() => T;
}

export interface AmenitiesPreviousValues {
  id: ID_Output;
  elevator: Boolean;
  petsAllowed: Boolean;
  internet: Boolean;
  kitchen: Boolean;
  wirelessInternet: Boolean;
  familyKidFriendly: Boolean;
  freeParkingOnPremises: Boolean;
  hotTub: Boolean;
  pool: Boolean;
  smokingAllowed: Boolean;
  wheelchairAccessible: Boolean;
  breakfast: Boolean;
  cableTv: Boolean;
  suitableForEvents: Boolean;
  dryer: Boolean;
  washer: Boolean;
  indoorFireplace: Boolean;
  tv: Boolean;
  heating: Boolean;
  hangers: Boolean;
  iron: Boolean;
  hairDryer: Boolean;
  doorman: Boolean;
  paidParkingOffPremises: Boolean;
  freeParkingOnStreet: Boolean;
  gym: Boolean;
  airConditioning: Boolean;
  shampoo: Boolean;
  essentials: Boolean;
  laptopFriendlyWorkspace: Boolean;
  privateEntrance: Boolean;
  buzzerWirelessIntercom: Boolean;
  babyBath: Boolean;
  babyMonitor: Boolean;
  babysitterRecommendations: Boolean;
  bathtub: Boolean;
  changingTable: Boolean;
  childrensBooksAndToys: Boolean;
  childrensDinnerware: Boolean;
  crib: Boolean;
}

export interface AmenitiesPreviousValuesPromise
  extends Promise<AmenitiesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  elevator: () => Promise<Boolean>;
  petsAllowed: () => Promise<Boolean>;
  internet: () => Promise<Boolean>;
  kitchen: () => Promise<Boolean>;
  wirelessInternet: () => Promise<Boolean>;
  familyKidFriendly: () => Promise<Boolean>;
  freeParkingOnPremises: () => Promise<Boolean>;
  hotTub: () => Promise<Boolean>;
  pool: () => Promise<Boolean>;
  smokingAllowed: () => Promise<Boolean>;
  wheelchairAccessible: () => Promise<Boolean>;
  breakfast: () => Promise<Boolean>;
  cableTv: () => Promise<Boolean>;
  suitableForEvents: () => Promise<Boolean>;
  dryer: () => Promise<Boolean>;
  washer: () => Promise<Boolean>;
  indoorFireplace: () => Promise<Boolean>;
  tv: () => Promise<Boolean>;
  heating: () => Promise<Boolean>;
  hangers: () => Promise<Boolean>;
  iron: () => Promise<Boolean>;
  hairDryer: () => Promise<Boolean>;
  doorman: () => Promise<Boolean>;
  paidParkingOffPremises: () => Promise<Boolean>;
  freeParkingOnStreet: () => Promise<Boolean>;
  gym: () => Promise<Boolean>;
  airConditioning: () => Promise<Boolean>;
  shampoo: () => Promise<Boolean>;
  essentials: () => Promise<Boolean>;
  laptopFriendlyWorkspace: () => Promise<Boolean>;
  privateEntrance: () => Promise<Boolean>;
  buzzerWirelessIntercom: () => Promise<Boolean>;
  babyBath: () => Promise<Boolean>;
  babyMonitor: () => Promise<Boolean>;
  babysitterRecommendations: () => Promise<Boolean>;
  bathtub: () => Promise<Boolean>;
  changingTable: () => Promise<Boolean>;
  childrensBooksAndToys: () => Promise<Boolean>;
  childrensDinnerware: () => Promise<Boolean>;
  crib: () => Promise<Boolean>;
}

export interface AmenitiesPreviousValuesSubscription
  extends Promise<AsyncIterator<AmenitiesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  elevator: () => Promise<AsyncIterator<Boolean>>;
  petsAllowed: () => Promise<AsyncIterator<Boolean>>;
  internet: () => Promise<AsyncIterator<Boolean>>;
  kitchen: () => Promise<AsyncIterator<Boolean>>;
  wirelessInternet: () => Promise<AsyncIterator<Boolean>>;
  familyKidFriendly: () => Promise<AsyncIterator<Boolean>>;
  freeParkingOnPremises: () => Promise<AsyncIterator<Boolean>>;
  hotTub: () => Promise<AsyncIterator<Boolean>>;
  pool: () => Promise<AsyncIterator<Boolean>>;
  smokingAllowed: () => Promise<AsyncIterator<Boolean>>;
  wheelchairAccessible: () => Promise<AsyncIterator<Boolean>>;
  breakfast: () => Promise<AsyncIterator<Boolean>>;
  cableTv: () => Promise<AsyncIterator<Boolean>>;
  suitableForEvents: () => Promise<AsyncIterator<Boolean>>;
  dryer: () => Promise<AsyncIterator<Boolean>>;
  washer: () => Promise<AsyncIterator<Boolean>>;
  indoorFireplace: () => Promise<AsyncIterator<Boolean>>;
  tv: () => Promise<AsyncIterator<Boolean>>;
  heating: () => Promise<AsyncIterator<Boolean>>;
  hangers: () => Promise<AsyncIterator<Boolean>>;
  iron: () => Promise<AsyncIterator<Boolean>>;
  hairDryer: () => Promise<AsyncIterator<Boolean>>;
  doorman: () => Promise<AsyncIterator<Boolean>>;
  paidParkingOffPremises: () => Promise<AsyncIterator<Boolean>>;
  freeParkingOnStreet: () => Promise<AsyncIterator<Boolean>>;
  gym: () => Promise<AsyncIterator<Boolean>>;
  airConditioning: () => Promise<AsyncIterator<Boolean>>;
  shampoo: () => Promise<AsyncIterator<Boolean>>;
  essentials: () => Promise<AsyncIterator<Boolean>>;
  laptopFriendlyWorkspace: () => Promise<AsyncIterator<Boolean>>;
  privateEntrance: () => Promise<AsyncIterator<Boolean>>;
  buzzerWirelessIntercom: () => Promise<AsyncIterator<Boolean>>;
  babyBath: () => Promise<AsyncIterator<Boolean>>;
  babyMonitor: () => Promise<AsyncIterator<Boolean>>;
  babysitterRecommendations: () => Promise<AsyncIterator<Boolean>>;
  bathtub: () => Promise<AsyncIterator<Boolean>>;
  changingTable: () => Promise<AsyncIterator<Boolean>>;
  childrensBooksAndToys: () => Promise<AsyncIterator<Boolean>>;
  childrensDinnerware: () => Promise<AsyncIterator<Boolean>>;
  crib: () => Promise<AsyncIterator<Boolean>>;
}

export interface RestaurantEdge {
  cursor: String;
}

export interface RestaurantEdgePromise
  extends Promise<RestaurantEdge>,
    Fragmentable {
  node: <T = RestaurantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RestaurantEdgeSubscription
  extends Promise<AsyncIterator<RestaurantEdge>>,
    Fragmentable {
  node: <T = RestaurantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAmenities {
  count: Int;
}

export interface AggregateAmenitiesPromise
  extends Promise<AggregateAmenities>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAmenitiesSubscription
  extends Promise<AsyncIterator<AggregateAmenities>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost: Boolean;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  responseRate: () => Promise<Float>;
  responseTime: () => Promise<Int>;
  isSuperHost: () => Promise<Boolean>;
  ownedPlaces: <T = FragmentableArray<Place>>(
    args?: {
      where?: PlaceWhereInput;
      orderBy?: PlaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  location: <T = LocationPromise>() => T;
  bookings: <T = FragmentableArray<Booking>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  paymentAccount: <T = FragmentableArray<PaymentAccount>>(
    args?: {
      where?: PaymentAccountWhereInput;
      orderBy?: PaymentAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sentMessages: <T = FragmentableArray<Message>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  receivedMessages: <T = FragmentableArray<Message>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  notifications: <T = FragmentableArray<Notification>>(
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  profilePicture: <T = PicturePromise>() => T;
  hostingExperiences: <T = FragmentableArray<Experience>>(
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  responseRate: () => Promise<AsyncIterator<Float>>;
  responseTime: () => Promise<AsyncIterator<Int>>;
  isSuperHost: () => Promise<AsyncIterator<Boolean>>;
  ownedPlaces: <T = Promise<AsyncIterator<PlaceSubscription>>>(
    args?: {
      where?: PlaceWhereInput;
      orderBy?: PlaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  location: <T = LocationSubscription>() => T;
  bookings: <T = Promise<AsyncIterator<BookingSubscription>>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  paymentAccount: <T = Promise<AsyncIterator<PaymentAccountSubscription>>>(
    args?: {
      where?: PaymentAccountWhereInput;
      orderBy?: PaymentAccountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sentMessages: <T = Promise<AsyncIterator<MessageSubscription>>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  receivedMessages: <T = Promise<AsyncIterator<MessageSubscription>>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  notifications: <T = Promise<AsyncIterator<NotificationSubscription>>>(
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  profilePicture: <T = PictureSubscription>() => T;
  hostingExperiences: <T = Promise<AsyncIterator<ExperienceSubscription>>>(
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface BookingSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface BookingSubscriptionPayloadPromise
  extends Promise<BookingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookingPreviousValuesPromise>() => T;
}

export interface BookingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookingPreviousValuesSubscription>() => T;
}

export interface PricingEdge {
  cursor: String;
}

export interface PricingEdgePromise extends Promise<PricingEdge>, Fragmentable {
  node: <T = PricingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PricingEdgeSubscription
  extends Promise<AsyncIterator<PricingEdge>>,
    Fragmentable {
  node: <T = PricingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BookingPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
}

export interface BookingPreviousValuesPromise
  extends Promise<BookingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
}

export interface BookingPreviousValuesSubscription
  extends Promise<AsyncIterator<BookingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregatePolicies {
  count: Int;
}

export interface AggregatePoliciesPromise
  extends Promise<AggregatePolicies>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePoliciesSubscription
  extends Promise<AsyncIterator<AggregatePolicies>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AmenitiesEdge {
  cursor: String;
}

export interface AmenitiesEdgePromise
  extends Promise<AmenitiesEdge>,
    Fragmentable {
  node: <T = AmenitiesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AmenitiesEdgeSubscription
  extends Promise<AsyncIterator<AmenitiesEdge>>,
    Fragmentable {
  node: <T = AmenitiesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PoliciesConnection {}

export interface PoliciesConnectionPromise
  extends Promise<PoliciesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PoliciesEdge>>() => T;
  aggregate: <T = AggregatePoliciesPromise>() => T;
}

export interface PoliciesConnectionSubscription
  extends Promise<AsyncIterator<PoliciesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PoliciesEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePoliciesSubscription>() => T;
}

export interface CitySubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CitySubscriptionPayloadPromise
  extends Promise<CitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CityPreviousValuesPromise>() => T;
}

export interface CitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CityPreviousValuesSubscription>() => T;
}

export interface AggregatePlace {
  count: Int;
}

export interface AggregatePlacePromise
  extends Promise<AggregatePlace>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlaceSubscription
  extends Promise<AsyncIterator<AggregatePlace>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CityPreviousValues {
  id: ID_Output;
  name: String;
}

export interface CityPreviousValuesPromise
  extends Promise<CityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CityPreviousValuesSubscription
  extends Promise<AsyncIterator<CityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface PlaceConnection {}

export interface PlaceConnectionPromise
  extends Promise<PlaceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlaceEdge>>() => T;
  aggregate: <T = AggregatePlacePromise>() => T;
}

export interface PlaceConnectionSubscription
  extends Promise<AsyncIterator<PlaceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlaceEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlaceSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface PictureEdge {
  cursor: String;
}

export interface PictureEdgePromise extends Promise<PictureEdge>, Fragmentable {
  node: <T = PicturePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PictureEdgeSubscription
  extends Promise<AsyncIterator<PictureEdge>>,
    Fragmentable {
  node: <T = PictureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CreditCardInformationSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CreditCardInformationSubscriptionPayloadPromise
  extends Promise<CreditCardInformationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CreditCardInformationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CreditCardInformationPreviousValuesPromise>() => T;
}

export interface CreditCardInformationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CreditCardInformationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CreditCardInformationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CreditCardInformationPreviousValuesSubscription>() => T;
}

export interface AggregatePaypalInformation {
  count: Int;
}

export interface AggregatePaypalInformationPromise
  extends Promise<AggregatePaypalInformation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaypalInformationSubscription
  extends Promise<AsyncIterator<AggregatePaypalInformation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CreditCardInformationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  cardNumber: String;
  expiresOnMonth: Int;
  expiresOnYear: Int;
  securityCode: String;
  firstName: String;
  lastName: String;
  postalCode: String;
  country: String;
}

export interface CreditCardInformationPreviousValuesPromise
  extends Promise<CreditCardInformationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  cardNumber: () => Promise<String>;
  expiresOnMonth: () => Promise<Int>;
  expiresOnYear: () => Promise<Int>;
  securityCode: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  postalCode: () => Promise<String>;
  country: () => Promise<String>;
}

export interface CreditCardInformationPreviousValuesSubscription
  extends Promise<AsyncIterator<CreditCardInformationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  cardNumber: () => Promise<AsyncIterator<String>>;
  expiresOnMonth: () => Promise<AsyncIterator<Int>>;
  expiresOnYear: () => Promise<AsyncIterator<Int>>;
  securityCode: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  postalCode: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
}

export interface PaypalInformationConnection {}

export interface PaypalInformationConnectionPromise
  extends Promise<PaypalInformationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaypalInformationEdge>>() => T;
  aggregate: <T = AggregatePaypalInformationPromise>() => T;
}

export interface PaypalInformationConnectionSubscription
  extends Promise<AsyncIterator<PaypalInformationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaypalInformationEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaypalInformationSubscription>() => T;
}

export interface AmenitiesConnection {}

export interface AmenitiesConnectionPromise
  extends Promise<AmenitiesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AmenitiesEdge>>() => T;
  aggregate: <T = AggregateAmenitiesPromise>() => T;
}

export interface AmenitiesConnectionSubscription
  extends Promise<AsyncIterator<AmenitiesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AmenitiesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAmenitiesSubscription>() => T;
}

export interface PaymentAccountEdge {
  cursor: String;
}

export interface PaymentAccountEdgePromise
  extends Promise<PaymentAccountEdge>,
    Fragmentable {
  node: <T = PaymentAccountPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentAccountEdgeSubscription
  extends Promise<AsyncIterator<PaymentAccountEdge>>,
    Fragmentable {
  node: <T = PaymentAccountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExperienceSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExperienceSubscriptionPayloadPromise
  extends Promise<ExperienceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExperiencePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExperiencePreviousValuesPromise>() => T;
}

export interface ExperienceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExperienceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExperienceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExperiencePreviousValuesSubscription>() => T;
}

export interface AggregatePayment {
  count: Int;
}

export interface AggregatePaymentPromise
  extends Promise<AggregatePayment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentSubscription
  extends Promise<AsyncIterator<AggregatePayment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExperiencePreviousValues {
  id: ID_Output;
  title: String;
  pricePerPerson: Int;
  popularity: Int;
}

export interface ExperiencePreviousValuesPromise
  extends Promise<ExperiencePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  pricePerPerson: () => Promise<Int>;
  popularity: () => Promise<Int>;
}

export interface ExperiencePreviousValuesSubscription
  extends Promise<AsyncIterator<ExperiencePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  pricePerPerson: () => Promise<AsyncIterator<Int>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentConnection {}

export interface PaymentConnectionPromise
  extends Promise<PaymentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentEdge>>() => T;
  aggregate: <T = AggregatePaymentPromise>() => T;
}

export interface PaymentConnectionSubscription
  extends Promise<AsyncIterator<PaymentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentSubscription>() => T;
}

export interface HouseRules {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  suitableForChildren?: Boolean;
  suitableForInfants?: Boolean;
  petsAllowed?: Boolean;
  smokingAllowed?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  additionalRules?: String;
}

export interface HouseRulesPromise extends Promise<HouseRules>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  suitableForChildren: () => Promise<Boolean>;
  suitableForInfants: () => Promise<Boolean>;
  petsAllowed: () => Promise<Boolean>;
  smokingAllowed: () => Promise<Boolean>;
  partiesAndEventsAllowed: () => Promise<Boolean>;
  additionalRules: () => Promise<String>;
}

export interface HouseRulesSubscription
  extends Promise<AsyncIterator<HouseRules>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  suitableForChildren: () => Promise<AsyncIterator<Boolean>>;
  suitableForInfants: () => Promise<AsyncIterator<Boolean>>;
  petsAllowed: () => Promise<AsyncIterator<Boolean>>;
  smokingAllowed: () => Promise<AsyncIterator<Boolean>>;
  partiesAndEventsAllowed: () => Promise<AsyncIterator<Boolean>>;
  additionalRules: () => Promise<AsyncIterator<String>>;
}

export interface NotificationEdge {
  cursor: String;
}

export interface NotificationEdgePromise
  extends Promise<NotificationEdge>,
    Fragmentable {
  node: <T = NotificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NotificationEdgeSubscription
  extends Promise<AsyncIterator<NotificationEdge>>,
    Fragmentable {
  node: <T = NotificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExperienceCategorySubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExperienceCategorySubscriptionPayloadPromise
  extends Promise<ExperienceCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExperienceCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExperienceCategoryPreviousValuesPromise>() => T;
}

export interface ExperienceCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExperienceCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExperienceCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExperienceCategoryPreviousValuesSubscription>() => T;
}

export interface AggregateNeighbourhood {
  count: Int;
}

export interface AggregateNeighbourhoodPromise
  extends Promise<AggregateNeighbourhood>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNeighbourhoodSubscription
  extends Promise<AsyncIterator<AggregateNeighbourhood>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExperienceCategoryPreviousValues {
  id: ID_Output;
  mainColor: String;
  name: String;
}

export interface ExperienceCategoryPreviousValuesPromise
  extends Promise<ExperienceCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  mainColor: () => Promise<String>;
  name: () => Promise<String>;
}

export interface ExperienceCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<ExperienceCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  mainColor: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface NeighbourhoodConnection {}

export interface NeighbourhoodConnectionPromise
  extends Promise<NeighbourhoodConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NeighbourhoodEdge>>() => T;
  aggregate: <T = AggregateNeighbourhoodPromise>() => T;
}

export interface NeighbourhoodConnectionSubscription
  extends Promise<AsyncIterator<NeighbourhoodConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NeighbourhoodEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNeighbourhoodSubscription>() => T;
}

export interface Policies {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  checkInStartTime: Float;
  checkInEndTime: Float;
  checkoutTime: Float;
}

export interface PoliciesPromise extends Promise<Policies>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  checkInStartTime: () => Promise<Float>;
  checkInEndTime: () => Promise<Float>;
  checkoutTime: () => Promise<Float>;
  place: <T = PlacePromise>() => T;
}

export interface PoliciesSubscription
  extends Promise<AsyncIterator<Policies>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  checkInStartTime: () => Promise<AsyncIterator<Float>>;
  checkInEndTime: () => Promise<AsyncIterator<Float>>;
  checkoutTime: () => Promise<AsyncIterator<Float>>;
  place: <T = PlaceSubscription>() => T;
}

export interface MessageEdge {
  cursor: String;
}

export interface MessageEdgePromise extends Promise<MessageEdge>, Fragmentable {
  node: <T = MessagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MessageEdgeSubscription
  extends Promise<AsyncIterator<MessageEdge>>,
    Fragmentable {
  node: <T = MessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GuestRequirementsSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface GuestRequirementsSubscriptionPayloadPromise
  extends Promise<GuestRequirementsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GuestRequirementsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GuestRequirementsPreviousValuesPromise>() => T;
}

export interface GuestRequirementsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GuestRequirementsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GuestRequirementsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GuestRequirementsPreviousValuesSubscription>() => T;
}

export interface AggregateLocation {
  count: Int;
}

export interface AggregateLocationPromise
  extends Promise<AggregateLocation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationSubscription
  extends Promise<AsyncIterator<AggregateLocation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GuestRequirementsPreviousValues {
  id: ID_Output;
  govIssuedId: Boolean;
  recommendationsFromOtherHosts: Boolean;
  guestTripInformation: Boolean;
}

export interface GuestRequirementsPreviousValuesPromise
  extends Promise<GuestRequirementsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  govIssuedId: () => Promise<Boolean>;
  recommendationsFromOtherHosts: () => Promise<Boolean>;
  guestTripInformation: () => Promise<Boolean>;
}

export interface GuestRequirementsPreviousValuesSubscription
  extends Promise<AsyncIterator<GuestRequirementsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  govIssuedId: () => Promise<AsyncIterator<Boolean>>;
  recommendationsFromOtherHosts: () => Promise<AsyncIterator<Boolean>>;
  guestTripInformation: () => Promise<AsyncIterator<Boolean>>;
}

export interface LocationConnection {}

export interface LocationConnectionPromise
  extends Promise<LocationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LocationEdge>>() => T;
  aggregate: <T = AggregateLocationPromise>() => T;
}

export interface LocationConnectionSubscription
  extends Promise<AsyncIterator<LocationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationSubscription>() => T;
}

export interface GuestRequirements {
  id: ID_Output;
  govIssuedId: Boolean;
  recommendationsFromOtherHosts: Boolean;
  guestTripInformation: Boolean;
}

export interface GuestRequirementsPromise
  extends Promise<GuestRequirements>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  govIssuedId: () => Promise<Boolean>;
  recommendationsFromOtherHosts: () => Promise<Boolean>;
  guestTripInformation: () => Promise<Boolean>;
  place: <T = PlacePromise>() => T;
}

export interface GuestRequirementsSubscription
  extends Promise<AsyncIterator<GuestRequirements>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  govIssuedId: () => Promise<AsyncIterator<Boolean>>;
  recommendationsFromOtherHosts: () => Promise<AsyncIterator<Boolean>>;
  guestTripInformation: () => Promise<AsyncIterator<Boolean>>;
  place: <T = PlaceSubscription>() => T;
}

export interface HouseRulesEdge {
  cursor: String;
}

export interface HouseRulesEdgePromise
  extends Promise<HouseRulesEdge>,
    Fragmentable {
  node: <T = HouseRulesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HouseRulesEdgeSubscription
  extends Promise<AsyncIterator<HouseRulesEdge>>,
    Fragmentable {
  node: <T = HouseRulesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HouseRulesSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface HouseRulesSubscriptionPayloadPromise
  extends Promise<HouseRulesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HouseRulesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HouseRulesPreviousValuesPromise>() => T;
}

export interface HouseRulesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HouseRulesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HouseRulesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HouseRulesPreviousValuesSubscription>() => T;
}

export interface AggregateGuestRequirements {
  count: Int;
}

export interface AggregateGuestRequirementsPromise
  extends Promise<AggregateGuestRequirements>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGuestRequirementsSubscription
  extends Promise<AsyncIterator<AggregateGuestRequirements>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HouseRulesPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  suitableForChildren?: Boolean;
  suitableForInfants?: Boolean;
  petsAllowed?: Boolean;
  smokingAllowed?: Boolean;
  partiesAndEventsAllowed?: Boolean;
  additionalRules?: String;
}

export interface HouseRulesPreviousValuesPromise
  extends Promise<HouseRulesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  suitableForChildren: () => Promise<Boolean>;
  suitableForInfants: () => Promise<Boolean>;
  petsAllowed: () => Promise<Boolean>;
  smokingAllowed: () => Promise<Boolean>;
  partiesAndEventsAllowed: () => Promise<Boolean>;
  additionalRules: () => Promise<String>;
}

export interface HouseRulesPreviousValuesSubscription
  extends Promise<AsyncIterator<HouseRulesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  suitableForChildren: () => Promise<AsyncIterator<Boolean>>;
  suitableForInfants: () => Promise<AsyncIterator<Boolean>>;
  petsAllowed: () => Promise<AsyncIterator<Boolean>>;
  smokingAllowed: () => Promise<AsyncIterator<Boolean>>;
  partiesAndEventsAllowed: () => Promise<AsyncIterator<Boolean>>;
  additionalRules: () => Promise<AsyncIterator<String>>;
}

export interface GuestRequirementsConnection {}

export interface GuestRequirementsConnectionPromise
  extends Promise<GuestRequirementsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GuestRequirementsEdge>>() => T;
  aggregate: <T = AggregateGuestRequirementsPromise>() => T;
}

export interface GuestRequirementsConnectionSubscription
  extends Promise<AsyncIterator<GuestRequirementsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GuestRequirementsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGuestRequirementsSubscription>() => T;
}

export interface Views {
  id: ID_Output;
  lastWeek: Int;
}

export interface ViewsPromise extends Promise<Views>, Fragmentable {
  id: () => Promise<ID_Output>;
  lastWeek: () => Promise<Int>;
  place: <T = PlacePromise>() => T;
}

export interface ViewsSubscription
  extends Promise<AsyncIterator<Views>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lastWeek: () => Promise<AsyncIterator<Int>>;
  place: <T = PlaceSubscription>() => T;
}

export interface AggregateExperienceCategory {
  count: Int;
}

export interface AggregateExperienceCategoryPromise
  extends Promise<AggregateExperienceCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExperienceCategorySubscription
  extends Promise<AsyncIterator<AggregateExperienceCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface LocationSubscriptionPayloadPromise
  extends Promise<LocationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LocationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationPreviousValuesPromise>() => T;
}

export interface LocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationPreviousValuesSubscription>() => T;
}

export interface ExperienceCategoryConnection {}

export interface ExperienceCategoryConnectionPromise
  extends Promise<ExperienceCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExperienceCategoryEdge>>() => T;
  aggregate: <T = AggregateExperienceCategoryPromise>() => T;
}

export interface ExperienceCategoryConnectionSubscription
  extends Promise<AsyncIterator<ExperienceCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ExperienceCategoryEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateExperienceCategorySubscription>() => T;
}

export interface LocationPreviousValues {
  id: ID_Output;
  lat: Float;
  lng: Float;
  address: String;
  directions: String;
}

export interface LocationPreviousValuesPromise
  extends Promise<LocationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  address: () => Promise<String>;
  directions: () => Promise<String>;
}

export interface LocationPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  address: () => Promise<AsyncIterator<String>>;
  directions: () => Promise<AsyncIterator<String>>;
}

export interface ExperienceEdge {
  cursor: String;
}

export interface ExperienceEdgePromise
  extends Promise<ExperienceEdge>,
    Fragmentable {
  node: <T = ExperiencePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExperienceEdgeSubscription
  extends Promise<AsyncIterator<ExperienceEdge>>,
    Fragmentable {
  node: <T = ExperienceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Pricing {
  id: ID_Output;
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight: Int;
  smartPricing: Boolean;
  basePrice: Int;
  averageWeekly: Int;
  averageMonthly: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export interface PricingPromise extends Promise<Pricing>, Fragmentable {
  id: () => Promise<ID_Output>;
  place: <T = PlacePromise>() => T;
  monthlyDiscount: () => Promise<Int>;
  weeklyDiscount: () => Promise<Int>;
  perNight: () => Promise<Int>;
  smartPricing: () => Promise<Boolean>;
  basePrice: () => Promise<Int>;
  averageWeekly: () => Promise<Int>;
  averageMonthly: () => Promise<Int>;
  cleaningFee: () => Promise<Int>;
  securityDeposit: () => Promise<Int>;
  extraGuests: () => Promise<Int>;
  weekendPricing: () => Promise<Int>;
  currency: () => Promise<CURRENCY>;
}

export interface PricingSubscription
  extends Promise<AsyncIterator<Pricing>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  place: <T = PlaceSubscription>() => T;
  monthlyDiscount: () => Promise<AsyncIterator<Int>>;
  weeklyDiscount: () => Promise<AsyncIterator<Int>>;
  perNight: () => Promise<AsyncIterator<Int>>;
  smartPricing: () => Promise<AsyncIterator<Boolean>>;
  basePrice: () => Promise<AsyncIterator<Int>>;
  averageWeekly: () => Promise<AsyncIterator<Int>>;
  averageMonthly: () => Promise<AsyncIterator<Int>>;
  cleaningFee: () => Promise<AsyncIterator<Int>>;
  securityDeposit: () => Promise<AsyncIterator<Int>>;
  extraGuests: () => Promise<AsyncIterator<Int>>;
  weekendPricing: () => Promise<AsyncIterator<Int>>;
  currency: () => Promise<AsyncIterator<CURRENCY>>;
}

export interface AggregateCreditCardInformation {
  count: Int;
}

export interface AggregateCreditCardInformationPromise
  extends Promise<AggregateCreditCardInformation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCreditCardInformationSubscription
  extends Promise<AsyncIterator<AggregateCreditCardInformation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MessageSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface MessageSubscriptionPayloadPromise
  extends Promise<MessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MessagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MessagePreviousValuesPromise>() => T;
}

export interface MessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MessagePreviousValuesSubscription>() => T;
}

export interface CreditCardInformationConnection {}

export interface CreditCardInformationConnectionPromise
  extends Promise<CreditCardInformationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CreditCardInformationEdge>>() => T;
  aggregate: <T = AggregateCreditCardInformationPromise>() => T;
}

export interface CreditCardInformationConnectionSubscription
  extends Promise<AsyncIterator<CreditCardInformationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CreditCardInformationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCreditCardInformationSubscription>() => T;
}

export interface MessagePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  deliveredAt: DateTimeOutput;
  readAt: DateTimeOutput;
}

export interface MessagePreviousValuesPromise
  extends Promise<MessagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  deliveredAt: () => Promise<DateTimeOutput>;
  readAt: () => Promise<DateTimeOutput>;
}

export interface MessagePreviousValuesSubscription
  extends Promise<AsyncIterator<MessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deliveredAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  readAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateCity {
  count: Int;
}

export interface AggregateCityPromise
  extends Promise<AggregateCity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCitySubscription
  extends Promise<AsyncIterator<AggregateCity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Notification {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type?: NOTIFICATION_TYPE;
  link: String;
  readDate: DateTimeOutput;
}

export interface NotificationPromise
  extends Promise<Notification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<NOTIFICATION_TYPE>;
  user: <T = UserPromise>() => T;
  link: () => Promise<String>;
  readDate: () => Promise<DateTimeOutput>;
}

export interface NotificationSubscription
  extends Promise<AsyncIterator<Notification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<NOTIFICATION_TYPE>>;
  user: <T = UserSubscription>() => T;
  link: () => Promise<AsyncIterator<String>>;
  readDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Place {
  id: ID_Output;
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  popularity: Int;
}

export interface PlacePromise extends Promise<Place>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  size: () => Promise<PLACE_SIZES>;
  shortDescription: () => Promise<String>;
  description: () => Promise<String>;
  slug: () => Promise<String>;
  maxGuests: () => Promise<Int>;
  numBedrooms: () => Promise<Int>;
  numBeds: () => Promise<Int>;
  numBaths: () => Promise<Int>;
  reviews: <T = FragmentableArray<Review>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  amenities: <T = AmenitiesPromise>() => T;
  host: <T = UserPromise>() => T;
  pricing: <T = PricingPromise>() => T;
  location: <T = LocationPromise>() => T;
  views: <T = ViewsPromise>() => T;
  guestRequirements: <T = GuestRequirementsPromise>() => T;
  policies: <T = PoliciesPromise>() => T;
  houseRules: <T = HouseRulesPromise>() => T;
  bookings: <T = FragmentableArray<Booking>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pictures: <T = FragmentableArray<Picture>>(
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  popularity: () => Promise<Int>;
}

export interface PlaceSubscription
  extends Promise<AsyncIterator<Place>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<PLACE_SIZES>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  maxGuests: () => Promise<AsyncIterator<Int>>;
  numBedrooms: () => Promise<AsyncIterator<Int>>;
  numBeds: () => Promise<AsyncIterator<Int>>;
  numBaths: () => Promise<AsyncIterator<Int>>;
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(
    args?: {
      where?: ReviewWhereInput;
      orderBy?: ReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  amenities: <T = AmenitiesSubscription>() => T;
  host: <T = UserSubscription>() => T;
  pricing: <T = PricingSubscription>() => T;
  location: <T = LocationSubscription>() => T;
  views: <T = ViewsSubscription>() => T;
  guestRequirements: <T = GuestRequirementsSubscription>() => T;
  policies: <T = PoliciesSubscription>() => T;
  houseRules: <T = HouseRulesSubscription>() => T;
  bookings: <T = Promise<AsyncIterator<BookingSubscription>>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pictures: <T = Promise<AsyncIterator<PictureSubscription>>>(
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface NeighbourhoodSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface NeighbourhoodSubscriptionPayloadPromise
  extends Promise<NeighbourhoodSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NeighbourhoodPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NeighbourhoodPreviousValuesPromise>() => T;
}

export interface NeighbourhoodSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NeighbourhoodSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NeighbourhoodSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NeighbourhoodPreviousValuesSubscription>() => T;
}

export interface ViewsSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ViewsSubscriptionPayloadPromise
  extends Promise<ViewsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ViewsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ViewsPreviousValuesPromise>() => T;
}

export interface ViewsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ViewsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ViewsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ViewsPreviousValuesSubscription>() => T;
}

export interface NeighbourhoodPreviousValues {
  id: ID_Output;
  name: String;
  slug: String;
  featured: Boolean;
  popularity: Int;
}

export interface NeighbourhoodPreviousValuesPromise
  extends Promise<NeighbourhoodPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  featured: () => Promise<Boolean>;
  popularity: () => Promise<Int>;
}

export interface NeighbourhoodPreviousValuesSubscription
  extends Promise<AsyncIterator<NeighbourhoodPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  featured: () => Promise<AsyncIterator<Boolean>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateRestaurant {
  count: Int;
}

export interface AggregateRestaurantPromise
  extends Promise<AggregateRestaurant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRestaurantSubscription
  extends Promise<AsyncIterator<AggregateRestaurant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Message {
  id: ID_Output;
  createdAt: DateTimeOutput;
  deliveredAt: DateTimeOutput;
  readAt: DateTimeOutput;
}

export interface MessagePromise extends Promise<Message>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  from: <T = UserPromise>() => T;
  to: <T = UserPromise>() => T;
  deliveredAt: () => Promise<DateTimeOutput>;
  readAt: () => Promise<DateTimeOutput>;
}

export interface MessageSubscription
  extends Promise<AsyncIterator<Message>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  from: <T = UserSubscription>() => T;
  to: <T = UserSubscription>() => T;
  deliveredAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  readAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregatePricing {
  count: Int;
}

export interface AggregatePricingPromise
  extends Promise<AggregatePricing>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePricingSubscription
  extends Promise<AsyncIterator<AggregatePricing>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NotificationSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface NotificationSubscriptionPayloadPromise
  extends Promise<NotificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotificationPreviousValuesPromise>() => T;
}

export interface NotificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NotificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NotificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotificationPreviousValuesSubscription>() => T;
}

export interface PoliciesEdge {
  cursor: String;
}

export interface PoliciesEdgePromise
  extends Promise<PoliciesEdge>,
    Fragmentable {
  node: <T = PoliciesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PoliciesEdgeSubscription
  extends Promise<AsyncIterator<PoliciesEdge>>,
    Fragmentable {
  node: <T = PoliciesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NotificationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type?: NOTIFICATION_TYPE;
  link: String;
  readDate: DateTimeOutput;
}

export interface NotificationPreviousValuesPromise
  extends Promise<NotificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<NOTIFICATION_TYPE>;
  link: () => Promise<String>;
  readDate: () => Promise<DateTimeOutput>;
}

export interface NotificationPreviousValuesSubscription
  extends Promise<AsyncIterator<NotificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<NOTIFICATION_TYPE>>;
  link: () => Promise<AsyncIterator<String>>;
  readDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlaceEdge {
  cursor: String;
}

export interface PlaceEdgePromise extends Promise<PlaceEdge>, Fragmentable {
  node: <T = PlacePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlaceEdgeSubscription
  extends Promise<AsyncIterator<PlaceEdge>>,
    Fragmentable {
  node: <T = PlaceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CreditCardInformation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  cardNumber: String;
  expiresOnMonth: Int;
  expiresOnYear: Int;
  securityCode: String;
  firstName: String;
  lastName: String;
  postalCode: String;
  country: String;
}

export interface CreditCardInformationPromise
  extends Promise<CreditCardInformation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  cardNumber: () => Promise<String>;
  expiresOnMonth: () => Promise<Int>;
  expiresOnYear: () => Promise<Int>;
  securityCode: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  postalCode: () => Promise<String>;
  country: () => Promise<String>;
  paymentAccount: <T = PaymentAccountPromise>() => T;
}

export interface CreditCardInformationSubscription
  extends Promise<AsyncIterator<CreditCardInformation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  cardNumber: () => Promise<AsyncIterator<String>>;
  expiresOnMonth: () => Promise<AsyncIterator<Int>>;
  expiresOnYear: () => Promise<AsyncIterator<Int>>;
  securityCode: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  postalCode: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  paymentAccount: <T = PaymentAccountSubscription>() => T;
}

export interface PictureConnection {}

export interface PictureConnectionPromise
  extends Promise<PictureConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PictureEdge>>() => T;
  aggregate: <T = AggregatePicturePromise>() => T;
}

export interface PictureConnectionSubscription
  extends Promise<AsyncIterator<PictureConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PictureEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePictureSubscription>() => T;
}

export interface PaymentSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PaymentSubscriptionPayloadPromise
  extends Promise<PaymentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentPreviousValuesPromise>() => T;
}

export interface PaymentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentPreviousValuesSubscription>() => T;
}

export interface AggregatePaymentAccount {
  count: Int;
}

export interface AggregatePaymentAccountPromise
  extends Promise<AggregatePaymentAccount>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentAccountSubscription
  extends Promise<AsyncIterator<AggregatePaymentAccount>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  serviceFee: Float;
  placePrice: Float;
  totalPrice: Float;
}

export interface PaymentPreviousValuesPromise
  extends Promise<PaymentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  serviceFee: () => Promise<Float>;
  placePrice: () => Promise<Float>;
  totalPrice: () => Promise<Float>;
}

export interface PaymentPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  serviceFee: () => Promise<AsyncIterator<Float>>;
  placePrice: () => Promise<AsyncIterator<Float>>;
  totalPrice: () => Promise<AsyncIterator<Float>>;
}

export interface PaymentEdge {
  cursor: String;
}

export interface PaymentEdgePromise extends Promise<PaymentEdge>, Fragmentable {
  node: <T = PaymentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentEdgeSubscription
  extends Promise<AsyncIterator<PaymentEdge>>,
    Fragmentable {
  node: <T = PaymentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PaypalInformation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email: String;
}

export interface PaypalInformationPromise
  extends Promise<PaypalInformation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  paymentAccount: <T = PaymentAccountPromise>() => T;
}

export interface PaypalInformationSubscription
  extends Promise<AsyncIterator<PaypalInformation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  paymentAccount: <T = PaymentAccountSubscription>() => T;
}

export interface NotificationConnection {}

export interface NotificationConnectionPromise
  extends Promise<NotificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NotificationEdge>>() => T;
  aggregate: <T = AggregateNotificationPromise>() => T;
}

export interface NotificationConnectionSubscription
  extends Promise<AsyncIterator<NotificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NotificationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNotificationSubscription>() => T;
}

export interface PaymentAccountSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PaymentAccountSubscriptionPayloadPromise
  extends Promise<PaymentAccountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentAccountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentAccountPreviousValuesPromise>() => T;
}

export interface PaymentAccountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentAccountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentAccountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentAccountPreviousValuesSubscription>() => T;
}

export interface AggregateMessage {
  count: Int;
}

export interface AggregateMessagePromise
  extends Promise<AggregateMessage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMessageSubscription
  extends Promise<AsyncIterator<AggregateMessage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentAccountPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type?: PAYMENT_PROVIDER;
}

export interface PaymentAccountPreviousValuesPromise
  extends Promise<PaymentAccountPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<PAYMENT_PROVIDER>;
}

export interface PaymentAccountPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentAccountPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<PAYMENT_PROVIDER>>;
}

export interface LocationEdge {
  cursor: String;
}

export interface LocationEdgePromise
  extends Promise<LocationEdge>,
    Fragmentable {
  node: <T = LocationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LocationEdgeSubscription
  extends Promise<AsyncIterator<LocationEdge>>,
    Fragmentable {
  node: <T = LocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PaymentAccount {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type?: PAYMENT_PROVIDER;
}

export interface PaymentAccountPromise
  extends Promise<PaymentAccount>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<PAYMENT_PROVIDER>;
  user: <T = UserPromise>() => T;
  payments: <T = FragmentableArray<Payment>>(
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  paypal: <T = PaypalInformationPromise>() => T;
  creditcard: <T = CreditCardInformationPromise>() => T;
}

export interface PaymentAccountSubscription
  extends Promise<AsyncIterator<PaymentAccount>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<PAYMENT_PROVIDER>>;
  user: <T = UserSubscription>() => T;
  payments: <T = Promise<AsyncIterator<PaymentSubscription>>>(
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  paypal: <T = PaypalInformationSubscription>() => T;
  creditcard: <T = CreditCardInformationSubscription>() => T;
}

export interface HouseRulesConnection {}

export interface HouseRulesConnectionPromise
  extends Promise<HouseRulesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HouseRulesEdge>>() => T;
  aggregate: <T = AggregateHouseRulesPromise>() => T;
}

export interface HouseRulesConnectionSubscription
  extends Promise<AsyncIterator<HouseRulesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HouseRulesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHouseRulesSubscription>() => T;
}

export interface PaypalInformationSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PaypalInformationSubscriptionPayloadPromise
  extends Promise<PaypalInformationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaypalInformationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaypalInformationPreviousValuesPromise>() => T;
}

export interface PaypalInformationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaypalInformationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaypalInformationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaypalInformationPreviousValuesSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface PaypalInformationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  email: String;
}

export interface PaypalInformationPreviousValuesPromise
  extends Promise<PaypalInformationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
}

export interface PaypalInformationPreviousValuesSubscription
  extends Promise<AsyncIterator<PaypalInformationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExperience {
  count: Int;
}

export interface AggregateExperiencePromise
  extends Promise<AggregateExperience>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExperienceSubscription
  extends Promise<AsyncIterator<AggregateExperience>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Payment {
  id: ID_Output;
  createdAt: DateTimeOutput;
  serviceFee: Float;
  placePrice: Float;
  totalPrice: Float;
}

export interface PaymentPromise extends Promise<Payment>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  serviceFee: () => Promise<Float>;
  placePrice: () => Promise<Float>;
  totalPrice: () => Promise<Float>;
  booking: <T = BookingPromise>() => T;
  paymentMethod: <T = PaymentAccountPromise>() => T;
}

export interface PaymentSubscription
  extends Promise<AsyncIterator<Payment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  serviceFee: () => Promise<AsyncIterator<Float>>;
  placePrice: () => Promise<AsyncIterator<Float>>;
  totalPrice: () => Promise<AsyncIterator<Float>>;
  booking: <T = BookingSubscription>() => T;
  paymentMethod: <T = PaymentAccountSubscription>() => T;
}

export interface CreditCardInformationEdge {
  cursor: String;
}

export interface CreditCardInformationEdgePromise
  extends Promise<CreditCardInformationEdge>,
    Fragmentable {
  node: <T = CreditCardInformationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CreditCardInformationEdgeSubscription
  extends Promise<AsyncIterator<CreditCardInformationEdge>>,
    Fragmentable {
  node: <T = CreditCardInformationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PictureSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PictureSubscriptionPayloadPromise
  extends Promise<PictureSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PicturePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PicturePreviousValuesPromise>() => T;
}

export interface PictureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PictureSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PictureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PicturePreviousValuesSubscription>() => T;
}

export interface ViewsEdge {
  cursor: String;
}

export interface ViewsEdgePromise extends Promise<ViewsEdge>, Fragmentable {
  node: <T = ViewsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ViewsEdgeSubscription
  extends Promise<AsyncIterator<ViewsEdge>>,
    Fragmentable {
  node: <T = ViewsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PicturePreviousValues {
  id: ID_Output;
  url: String;
}

export interface PicturePreviousValuesPromise
  extends Promise<PicturePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
}

export interface PicturePreviousValuesSubscription
  extends Promise<AsyncIterator<PicturePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface ReviewEdge {
  cursor: String;
}

export interface ReviewEdgePromise extends Promise<ReviewEdge>, Fragmentable {
  node: <T = ReviewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReviewEdgeSubscription
  extends Promise<AsyncIterator<ReviewEdge>>,
    Fragmentable {
  node: <T = ReviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Booking {
  id: ID_Output;
  createdAt: DateTimeOutput;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
}

export interface BookingPromise extends Promise<Booking>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  bookee: <T = UserPromise>() => T;
  place: <T = PlacePromise>() => T;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  payment: <T = PaymentPromise>() => T;
}

export interface BookingSubscription
  extends Promise<AsyncIterator<Booking>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  bookee: <T = UserSubscription>() => T;
  place: <T = PlaceSubscription>() => T;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  payment: <T = PaymentSubscription>() => T;
}

export interface PricingConnection {}

export interface PricingConnectionPromise
  extends Promise<PricingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PricingEdge>>() => T;
  aggregate: <T = AggregatePricingPromise>() => T;
}

export interface PricingConnectionSubscription
  extends Promise<AsyncIterator<PricingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PricingEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePricingSubscription>() => T;
}

export interface PlaceSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PlaceSubscriptionPayloadPromise
  extends Promise<PlaceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlacePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlacePreviousValuesPromise>() => T;
}

export interface PlaceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlaceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlaceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlacePreviousValuesSubscription>() => T;
}

export interface AggregatePicture {
  count: Int;
}

export interface AggregatePicturePromise
  extends Promise<AggregatePicture>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePictureSubscription
  extends Promise<AsyncIterator<AggregatePicture>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlacePreviousValues {
  id: ID_Output;
  name: String;
  size?: PLACE_SIZES;
  shortDescription: String;
  description: String;
  slug: String;
  maxGuests: Int;
  numBedrooms: Int;
  numBeds: Int;
  numBaths: Int;
  popularity: Int;
}

export interface PlacePreviousValuesPromise
  extends Promise<PlacePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  size: () => Promise<PLACE_SIZES>;
  shortDescription: () => Promise<String>;
  description: () => Promise<String>;
  slug: () => Promise<String>;
  maxGuests: () => Promise<Int>;
  numBedrooms: () => Promise<Int>;
  numBeds: () => Promise<Int>;
  numBaths: () => Promise<Int>;
  popularity: () => Promise<Int>;
}

export interface PlacePreviousValuesSubscription
  extends Promise<AsyncIterator<PlacePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<PLACE_SIZES>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  maxGuests: () => Promise<AsyncIterator<Int>>;
  numBedrooms: () => Promise<AsyncIterator<Int>>;
  numBeds: () => Promise<AsyncIterator<Int>>;
  numBaths: () => Promise<AsyncIterator<Int>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentAccountConnection {}

export interface PaymentAccountConnectionPromise
  extends Promise<PaymentAccountConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentAccountEdge>>() => T;
  aggregate: <T = AggregatePaymentAccountPromise>() => T;
}

export interface PaymentAccountConnectionSubscription
  extends Promise<AsyncIterator<PaymentAccountConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentAccountEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentAccountSubscription>() => T;
}

export interface Restaurant {
  id: ID_Output;
  createdAt: DateTimeOutput;
  title: String;
  avgPricePerPerson: Int;
  isCurated: Boolean;
  slug: String;
  popularity: Int;
}

export interface RestaurantPromise extends Promise<Restaurant>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  avgPricePerPerson: () => Promise<Int>;
  pictures: <T = FragmentableArray<Picture>>(
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  location: <T = LocationPromise>() => T;
  isCurated: () => Promise<Boolean>;
  slug: () => Promise<String>;
  popularity: () => Promise<Int>;
}

export interface RestaurantSubscription
  extends Promise<AsyncIterator<Restaurant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  avgPricePerPerson: () => Promise<AsyncIterator<Int>>;
  pictures: <T = Promise<AsyncIterator<PictureSubscription>>>(
    args?: {
      where?: PictureWhereInput;
      orderBy?: PictureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  location: <T = LocationSubscription>() => T;
  isCurated: () => Promise<AsyncIterator<Boolean>>;
  slug: () => Promise<AsyncIterator<String>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface NeighbourhoodEdge {
  cursor: String;
}

export interface NeighbourhoodEdgePromise
  extends Promise<NeighbourhoodEdge>,
    Fragmentable {
  node: <T = NeighbourhoodPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NeighbourhoodEdgeSubscription
  extends Promise<AsyncIterator<NeighbourhoodEdge>>,
    Fragmentable {
  node: <T = NeighbourhoodSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PoliciesSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PoliciesSubscriptionPayloadPromise
  extends Promise<PoliciesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PoliciesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PoliciesPreviousValuesPromise>() => T;
}

export interface PoliciesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PoliciesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PoliciesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PoliciesPreviousValuesSubscription>() => T;
}

export interface AggregateHouseRules {
  count: Int;
}

export interface AggregateHouseRulesPromise
  extends Promise<AggregateHouseRules>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHouseRulesSubscription
  extends Promise<AsyncIterator<AggregateHouseRules>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PoliciesPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  checkInStartTime: Float;
  checkInEndTime: Float;
  checkoutTime: Float;
}

export interface PoliciesPreviousValuesPromise
  extends Promise<PoliciesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  checkInStartTime: () => Promise<Float>;
  checkInEndTime: () => Promise<Float>;
  checkoutTime: () => Promise<Float>;
}

export interface PoliciesPreviousValuesSubscription
  extends Promise<AsyncIterator<PoliciesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  checkInStartTime: () => Promise<AsyncIterator<Float>>;
  checkInEndTime: () => Promise<AsyncIterator<Float>>;
  checkoutTime: () => Promise<AsyncIterator<Float>>;
}

export interface ExperienceCategoryEdge {
  cursor: String;
}

export interface ExperienceCategoryEdgePromise
  extends Promise<ExperienceCategoryEdge>,
    Fragmentable {
  node: <T = ExperienceCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExperienceCategoryEdgeSubscription
  extends Promise<AsyncIterator<ExperienceCategoryEdge>>,
    Fragmentable {
  node: <T = ExperienceCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface City {
  id: ID_Output;
  name: String;
}

export interface CityPromise extends Promise<City>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  neighbourhoods: <T = FragmentableArray<Neighbourhood>>(
    args?: {
      where?: NeighbourhoodWhereInput;
      orderBy?: NeighbourhoodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CitySubscription
  extends Promise<AsyncIterator<City>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  neighbourhoods: <T = Promise<AsyncIterator<NeighbourhoodSubscription>>>(
    args?: {
      where?: NeighbourhoodWhereInput;
      orderBy?: NeighbourhoodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Location {
  id: ID_Output;
  lat: Float;
  lng: Float;
  address: String;
  directions: String;
}

export interface LocationPromise extends Promise<Location>, Fragmentable {
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  neighbourHood: <T = NeighbourhoodPromise>() => T;
  user: <T = UserPromise>() => T;
  place: <T = PlacePromise>() => T;
  address: () => Promise<String>;
  directions: () => Promise<String>;
  experience: <T = ExperiencePromise>() => T;
  restaurant: <T = RestaurantPromise>() => T;
}

export interface LocationSubscription
  extends Promise<AsyncIterator<Location>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  neighbourHood: <T = NeighbourhoodSubscription>() => T;
  user: <T = UserSubscription>() => T;
  place: <T = PlaceSubscription>() => T;
  address: () => Promise<AsyncIterator<String>>;
  directions: () => Promise<AsyncIterator<String>>;
  experience: <T = ExperienceSubscription>() => T;
  restaurant: <T = RestaurantSubscription>() => T;
}

export interface PricingSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PricingSubscriptionPayloadPromise
  extends Promise<PricingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PricingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PricingPreviousValuesPromise>() => T;
}

export interface PricingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PricingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PricingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PricingPreviousValuesSubscription>() => T;
}

export interface RestaurantConnection {}

export interface RestaurantConnectionPromise
  extends Promise<RestaurantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RestaurantEdge>>() => T;
  aggregate: <T = AggregateRestaurantPromise>() => T;
}

export interface RestaurantConnectionSubscription
  extends Promise<AsyncIterator<RestaurantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RestaurantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRestaurantSubscription>() => T;
}

export interface PricingPreviousValues {
  id: ID_Output;
  monthlyDiscount?: Int;
  weeklyDiscount?: Int;
  perNight: Int;
  smartPricing: Boolean;
  basePrice: Int;
  averageWeekly: Int;
  averageMonthly: Int;
  cleaningFee?: Int;
  securityDeposit?: Int;
  extraGuests?: Int;
  weekendPricing?: Int;
  currency?: CURRENCY;
}

export interface PricingPreviousValuesPromise
  extends Promise<PricingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  monthlyDiscount: () => Promise<Int>;
  weeklyDiscount: () => Promise<Int>;
  perNight: () => Promise<Int>;
  smartPricing: () => Promise<Boolean>;
  basePrice: () => Promise<Int>;
  averageWeekly: () => Promise<Int>;
  averageMonthly: () => Promise<Int>;
  cleaningFee: () => Promise<Int>;
  securityDeposit: () => Promise<Int>;
  extraGuests: () => Promise<Int>;
  weekendPricing: () => Promise<Int>;
  currency: () => Promise<CURRENCY>;
}

export interface PricingPreviousValuesSubscription
  extends Promise<AsyncIterator<PricingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  monthlyDiscount: () => Promise<AsyncIterator<Int>>;
  weeklyDiscount: () => Promise<AsyncIterator<Int>>;
  perNight: () => Promise<AsyncIterator<Int>>;
  smartPricing: () => Promise<AsyncIterator<Boolean>>;
  basePrice: () => Promise<AsyncIterator<Int>>;
  averageWeekly: () => Promise<AsyncIterator<Int>>;
  averageMonthly: () => Promise<AsyncIterator<Int>>;
  cleaningFee: () => Promise<AsyncIterator<Int>>;
  securityDeposit: () => Promise<AsyncIterator<Int>>;
  extraGuests: () => Promise<AsyncIterator<Int>>;
  weekendPricing: () => Promise<AsyncIterator<Int>>;
  currency: () => Promise<AsyncIterator<CURRENCY>>;
}

export interface PaypalInformationEdge {
  cursor: String;
}

export interface PaypalInformationEdgePromise
  extends Promise<PaypalInformationEdge>,
    Fragmentable {
  node: <T = PaypalInformationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaypalInformationEdgeSubscription
  extends Promise<AsyncIterator<PaypalInformationEdge>>,
    Fragmentable {
  node: <T = PaypalInformationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Picture {
  id: ID_Output;
  url: String;
}

export interface PicturePromise extends Promise<Picture>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
}

export interface PictureSubscription
  extends Promise<AsyncIterator<Picture>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface MessageConnection {}

export interface MessageConnectionPromise
  extends Promise<MessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MessageEdge>>() => T;
  aggregate: <T = AggregateMessagePromise>() => T;
}

export interface MessageConnectionSubscription
  extends Promise<AsyncIterator<MessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MessageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMessageSubscription>() => T;
}

export interface ExperienceConnection {}

export interface ExperienceConnectionPromise
  extends Promise<ExperienceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExperienceEdge>>() => T;
  aggregate: <T = AggregateExperiencePromise>() => T;
}

export interface ExperienceConnectionSubscription
  extends Promise<AsyncIterator<ExperienceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExperienceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExperienceSubscription>() => T;
}

export interface ReviewSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ReviewSubscriptionPayloadPromise
  extends Promise<ReviewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReviewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReviewPreviousValuesPromise>() => T;
}

export interface ReviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReviewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReviewPreviousValuesSubscription>() => T;
}

export interface Neighbourhood {
  id: ID_Output;
  name: String;
  slug: String;
  featured: Boolean;
  popularity: Int;
}

export interface NeighbourhoodPromise
  extends Promise<Neighbourhood>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  locations: <T = FragmentableArray<Location>>(
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  homePreview: <T = PicturePromise>() => T;
  city: <T = CityPromise>() => T;
  featured: () => Promise<Boolean>;
  popularity: () => Promise<Int>;
}

export interface NeighbourhoodSubscription
  extends Promise<AsyncIterator<Neighbourhood>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  locations: <T = Promise<AsyncIterator<LocationSubscription>>>(
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  homePreview: <T = PictureSubscription>() => T;
  city: <T = CitySubscription>() => T;
  featured: () => Promise<AsyncIterator<Boolean>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface RestaurantPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  title: String;
  avgPricePerPerson: Int;
  isCurated: Boolean;
  slug: String;
  popularity: Int;
}

export interface RestaurantPreviousValuesPromise
  extends Promise<RestaurantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  avgPricePerPerson: () => Promise<Int>;
  isCurated: () => Promise<Boolean>;
  slug: () => Promise<String>;
  popularity: () => Promise<Int>;
}

export interface RestaurantPreviousValuesSubscription
  extends Promise<AsyncIterator<RestaurantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  avgPricePerPerson: () => Promise<AsyncIterator<Int>>;
  isCurated: () => Promise<AsyncIterator<Boolean>>;
  slug: () => Promise<AsyncIterator<String>>;
  popularity: () => Promise<AsyncIterator<Int>>;
}

export interface RestaurantSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface RestaurantSubscriptionPayloadPromise
  extends Promise<RestaurantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RestaurantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RestaurantPreviousValuesPromise>() => T;
}

export interface RestaurantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RestaurantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RestaurantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RestaurantPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GuestRequirementsEdge {
  cursor: String;
}

export interface GuestRequirementsEdgePromise
  extends Promise<GuestRequirementsEdge>,
    Fragmentable {
  node: <T = GuestRequirementsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GuestRequirementsEdgeSubscription
  extends Promise<AsyncIterator<GuestRequirementsEdge>>,
    Fragmentable {
  node: <T = GuestRequirementsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNotification {
  count: Int;
}

export interface AggregateNotificationPromise
  extends Promise<AggregateNotification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNotificationSubscription
  extends Promise<AsyncIterator<AggregateNotification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  responseRate?: Float;
  responseTime?: Int;
  isSuperHost: Boolean;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  responseRate: () => Promise<Float>;
  responseTime: () => Promise<Int>;
  isSuperHost: () => Promise<Boolean>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  responseRate: () => Promise<AsyncIterator<Float>>;
  responseTime: () => Promise<AsyncIterator<Int>>;
  isSuperHost: () => Promise<AsyncIterator<Boolean>>;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/**
 * Model Metadata
 */

export const models = [
  {
    name: "Amenities",
    embedded: false
  },
  {
    name: "Booking",
    embedded: false
  },
  {
    name: "CURRENCY",
    embedded: false
  },
  {
    name: "City",
    embedded: false
  },
  {
    name: "CreditCardInformation",
    embedded: false
  },
  {
    name: "Experience",
    embedded: false
  },
  {
    name: "ExperienceCategory",
    embedded: false
  },
  {
    name: "GuestRequirements",
    embedded: false
  },
  {
    name: "HouseRules",
    embedded: false
  },
  {
    name: "Location",
    embedded: false
  },
  {
    name: "Message",
    embedded: false
  },
  {
    name: "NOTIFICATION_TYPE",
    embedded: false
  },
  {
    name: "Neighbourhood",
    embedded: false
  },
  {
    name: "Notification",
    embedded: false
  },
  {
    name: "PAYMENT_PROVIDER",
    embedded: false
  },
  {
    name: "PLACE_SIZES",
    embedded: false
  },
  {
    name: "Payment",
    embedded: false
  },
  {
    name: "PaymentAccount",
    embedded: false
  },
  {
    name: "PaypalInformation",
    embedded: false
  },
  {
    name: "Picture",
    embedded: false
  },
  {
    name: "Place",
    embedded: false
  },
  {
    name: "Policies",
    embedded: false
  },
  {
    name: "Pricing",
    embedded: false
  },
  {
    name: "Restaurant",
    embedded: false
  },
  {
    name: "Review",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Views",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
